This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
contracts/
  .github/
    workflows/
      test.yml
  src/
    plugins/
      split/
        SplitPlugin.sol
  .gitignore
  foundry.toml
  README.md
packages/
  core/
    accounts/
      helpers.ts
      impl.ts
      index.ts
      tokens.ts
      types.ts
    bridge/
      providers/
        cctp/
          abi/
            evm/
              message_transmitter.json
          cctpBridge.ts
          cctpConstants.ts
          cctpUtils.ts
      impl.ts
      index.ts
      types.ts
    plugins/
      defs/
        multi-owner/
          abi.ts
          config.ts
        split/
          abi.ts
          config.ts
      gens/
        base/
          multi-owner/
            plugin.ts
          split/
            plugin.ts
        baseSepolia/
          multi-owner/
            plugin.ts
          split/
            plugin.ts
        sepolia/
          multi-owner/
            plugin.ts
          split/
            plugin.ts
      utils/
        helpers.ts
      index.ts
    trade/
      providers/
        cow/
          index.ts
      index.ts
      TradeService.ts
      types.ts
    index.ts
    package.json
    plugingen.config.ts
    README.md
    tsconfig.json
  examples/
    bridge-and-split/
      .env.example
      .gitignore
      index.ts
      package.json
      README.md
      tsconfig.json
    swap-and-split/
      .gitignore
      erc20-to-erc20.ts
      eth-to-erc20.ts
      package.json
      README.md
      tsconfig.json
.gitignore
.gitmodules
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/core/trade/providers/cow/index.ts">
import { OrderBookApi, SigningScheme, OrderKind } from '@cowprotocol/cow-sdk';
import type { TradeProvider, TradeParams, TradeQuote, TradeResult, TradeType } from '../../types.js';
import { type Address } from 'viem';

export class CowProtocolProvider implements TradeProvider {
    private orderBookApi: OrderBookApi;
    private chainId: number;
    private signer: any; // Replace with your actual signer type

    constructor(chainId: number, signer: any) {
        this.chainId = chainId;
        this.signer = signer;
        this.orderBookApi = new OrderBookApi({ chainId });
    }

    getName(): string {
        return 'CoW Protocol';
    }

    async getQuote(params: TradeParams): Promise<TradeQuote> {
        // Implementation using CoW SDK to get quotes
        // This will abstract all the complexity of CoW SDK quote requests
        // ...

        // Return formatted quote
        return {
            sellToken: { tokenAddress: params.sellToken, amount: BigInt(0) /* calculated */ },
            buyToken: { tokenAddress: params.buyToken, amount: BigInt(0) /* calculated */ },
            fee: { tokenAddress: params.sellToken, amount: BigInt(0) /* calculated */ },
            quoteId: "quoteId",
            validUntil: Date.now() + 300000, // 5 minutes
            executionPrice: 0 // calculated
        };
    }

    async executeTrade(quote: TradeQuote): Promise<TradeResult> {
        // Implementation using CoW SDK to execute trades
        // This will handle token approvals, order signing, and submission
        // ...

        return {
            success: true,
            transactionHash: "0x...",
            orderId: "0x...",
            status: "pending"
        };
    }

    async checkTradeStatus(orderId: string): Promise<string> {
        // Implementation to check order status
        // ...
        return "filled";
    }
}
</file>

<file path="packages/core/trade/index.ts">
export * from './types.js';
export * from './TradeService.js';
export { CowProtocolProvider } from './providers/cow/index.js';
</file>

<file path="packages/core/trade/TradeService.ts">
import type { TradeParams, TradeProvider, TradeQuote, TradeResult } from './types.js';
import { CowProtocolProvider } from './providers/cow/index.js';

export class TradeService {
  private provider: TradeProvider;

  constructor(provider: TradeProvider) {
    this.provider = provider;
  }

  static createCowProtocolService(chainId: number, signer: any): TradeService {
    return new TradeService(new CowProtocolProvider(chainId, signer));
  }

  async getQuote(params: TradeParams): Promise<TradeQuote> {
    return this.provider.getQuote(params);
  }

  async executeTrade(quote: TradeQuote): Promise<TradeResult> {
    return this.provider.executeTrade(quote);
  }

  async checkTradeStatus(orderId: string): Promise<string> {
    return this.provider.checkTradeStatus(orderId);
  }
}
</file>

<file path="packages/core/trade/types.ts">
import { type Address } from "viem";

export interface TradeOptions {
    slippageBps?: number;
    deadline?: number; // In seconds
    recipient?: Address;
}

export interface TokenAmount {
    tokenAddress: Address;
    amount: bigint;
}

export interface TradeQuote {
    sellToken: TokenAmount;
    buyToken: TokenAmount;
    fee: TokenAmount;
    quoteId: string;
    validUntil: number; // timestamp
    executionPrice: number;
}

export interface TradeResult {
    success: boolean;
    transactionHash?: string;
    orderId?: string;
    status?: string;
}

export enum TradeType {
    EXACT_INPUT = 'EXACT_INPUT', // Specify exact sell amount (sellToken)
    EXACT_OUTPUT = 'EXACT_OUTPUT' // Specify exact buy amount (buyToken)
}

export interface TradeParams {
    tradeType: TradeType;
    sellToken: Address;
    buyToken: Address;
    amount: string; // Amount of sellToken or buyToken depending on tradeType
    options?: TradeOptions;
}

export interface TradeProvider {
    getName(): string;
    getQuote(params: TradeParams): Promise<TradeQuote>;
    executeTrade(quote: TradeQuote): Promise<TradeResult>;
    checkTradeStatus(orderId: string): Promise<string>;
}
</file>

<file path="contracts/.github/workflows/test.yml">
name: CI

on:
  push:
  pull_request:
  workflow_dispatch:

env:
  FOUNDRY_PROFILE: ci

jobs:
  check:
    strategy:
      fail-fast: true

    name: Foundry project
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Show Forge version
        run: |
          forge --version

      - name: Run Forge fmt
        run: |
          forge fmt --check
        id: fmt

      - name: Run Forge build
        run: |
          forge build --sizes
        id: build

      - name: Run Forge tests
        run: |
          forge test -vvv
        id: test
</file>

<file path="contracts/.gitignore">
# Compiler files
cache/
out/
lib/

# Ignores development broadcast logs
!/broadcast
/broadcast/*/31337/
/broadcast/**/dry-run/

# Docs
docs/

# Dotenv file
.env
</file>

<file path="packages/core/accounts/helpers.ts">
import { base, baseSepolia, sepolia } from "@account-kit/infra";
import { EChain } from "./tokens.js";

const getUserOperationByHash = async (userOpHash: string, alchemyRpcUrl: string) => {
  const headers = {
    accept: "application/json",
    "content-type": "application/json",
  };

  const body = JSON.stringify({
    id: 1,
    jsonrpc: "2.0",
    method: "eth_getUserOperationByHash",
    params: [userOpHash],
  });

  try {
    const response = await fetch(alchemyRpcUrl, {
      method: "POST",
      headers: headers,
      body: body,
    });
    const data: any = await response.json();
    return data?.result?.transactionHash;
  } catch (e) {
    console.error(e);
  }
};

async function getTransactionReceipt(txHash: string, alchemyRpcUrl: string) {
  const headers = {
    accept: "application/json",
    "content-type": "application/json",
  };

  const body = JSON.stringify({
    id: 1,
    jsonrpc: "2.0",
    method: "eth_getTransactionReceipt",
    params: [txHash],
  });

  try {
    const response = await fetch(alchemyRpcUrl, {
      method: "POST",
      headers: headers,
      body: body,
    });

    const data: any = await response.json();
    return data?.result;
  } catch (error) {
    console.error("Error:", error);
  }
}

export const waitForTransaction = async (userOpHash: string, alchemyRpcUrl: string) => {
  console.log("Waiting for userOp confirmation...");

  let txHash;

  while (!txHash) {
    txHash = await getUserOperationByHash(userOpHash, alchemyRpcUrl);
    if (txHash) {
      console.log("txHash:", txHash);
      break;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000)); // Wait for 3 seconds before retrying
  }

  let txReceipt;
  console.log("Waiting for tx confirmation...");

  while (!txReceipt) {
    txReceipt = await getTransactionReceipt(txHash, alchemyRpcUrl);
    if (txReceipt) {
      console.log("Receipt:", txReceipt);
      break;
    }
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retrying
  }
}

export const adaptLockerChain2AlchemyChain = (lockerChain: EChain) => {
  switch (lockerChain) {
    case EChain.BASE:
      return base;
    case EChain.BASE_SEPOLIA:
      return baseSepolia;
    case EChain.SEPOLIA:
      return sepolia;
    case EChain.SOLANA:
    case EChain.SOLANA_DEVNET:
    default:
      throw new Error(`Unsupported chain: ${lockerChain}`);
  }
}
</file>

<file path="packages/core/accounts/tokens.ts">
export enum EChain {
    // ETHEREUM = 'ethereum',
    // AVALANCHE = 'avalanche',
    // OPTIMISM = 'optimism',
    // ARBITRUM = 'arbitrum',
    // NOBLE = 'noble',
    BASE = 'base',
    BASE_SEPOLIA = 'baseSepolia',
    SEPOLIA = 'sepolia',
    SOLANA = 'solana',
    SOLANA_DEVNET = 'solanaDevnet',
    // POLYGON = 'polygon',
    // SUI = 'sui',
    // APTOS = 'aptos',
    // UNICHAIN = 'unichain',
}

export const USDC: Record<EChain, string> = {
    [EChain.BASE]: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
    [EChain.BASE_SEPOLIA]: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
    [EChain.SEPOLIA]: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',
    [EChain.SOLANA]: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    [EChain.SOLANA_DEVNET]: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
}
</file>

<file path="packages/core/bridge/providers/cctp/abi/evm/message_transmitter.json">
[{"inputs":[{"internalType":"uint32","name":"_localDomain","type":"uint32"},{"internalType":"address","name":"_attester","type":"address"},{"internalType":"uint32","name":"_maxMessageBodySize","type":"uint32"},{"internalType":"uint32","name":"_version","type":"uint32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"attester","type":"address"}],"name":"AttesterDisabled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"attester","type":"address"}],"name":"AttesterEnabled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousAttesterManager","type":"address"},{"indexed":true,"internalType":"address","name":"newAttesterManager","type":"address"}],"name":"AttesterManagerUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newMaxMessageBodySize","type":"uint256"}],"name":"MaxMessageBodySizeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"indexed":true,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"MessageSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[],"name":"Pause","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newAddress","type":"address"}],"name":"PauserChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newRescuer","type":"address"}],"name":"RescuerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"oldSignatureThreshold","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newSignatureThreshold","type":"uint256"}],"name":"SignatureThresholdUpdated","type":"event"},{"anonymous":false,"inputs":[],"name":"Unpause","type":"event"},{"inputs":[],"name":"acceptOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"attesterManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"attester","type":"address"}],"name":"disableAttester","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newAttester","type":"address"}],"name":"enableAttester","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getEnabledAttester","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNumEnabledAttesters","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"attester","type":"address"}],"name":"isEnabledAttester","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxMessageBodySize","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextAvailableNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"attestation","type":"bytes"}],"name":"receiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"originalMessage","type":"bytes"},{"internalType":"bytes","name":"originalAttestation","type":"bytes"},{"internalType":"bytes","name":"newMessageBody","type":"bytes"},{"internalType":"bytes32","name":"newDestinationCaller","type":"bytes32"}],"name":"replaceMessage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"tokenContract","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"rescueERC20","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rescuer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"sendMessage","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"sendMessageWithCaller","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newMaxMessageBodySize","type":"uint256"}],"name":"setMaxMessageBodySize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newSignatureThreshold","type":"uint256"}],"name":"setSignatureThreshold","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"signatureThreshold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newAttesterManager","type":"address"}],"name":"updateAttesterManager","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPauser","type":"address"}],"name":"updatePauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newRescuer","type":"address"}],"name":"updateRescuer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"usedNonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"}]
</file>

<file path="packages/core/plugins/defs/multi-owner/abi.ts">
export const MultiOwnerPluginAbi = [
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      {
        name: "verifyingContract",
        type: "address",
        internalType: "address",
      },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      {
        name: "extensions",
        type: "uint256[]",
        internalType: "uint256[]",
      },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "encodeMessageData",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getMessageHash",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isOwnerOf",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "ownerToCheck", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "ownersOf",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          {
            name: "interfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          {
            name: "canSpendNativeToken",
            type: "bool",
            internalType: "bool",
          },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              {
                name: "permitAnySelector",
                type: "bool",
                internalType: "bool",
              },
              {
                name: "selectors",
                type: "bytes4[]",
                internalType: "bytes4[]",
              },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  {
                    name: "functionId",
                    type: "uint8",
                    internalType: "uint8",
                  },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  {
                    name: "functionId",
                    type: "uint8",
                    internalType: "uint8",
                  },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  {
                    name: "functionId",
                    type: "uint8",
                    internalType: "uint8",
                  },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  {
                    name: "functionId",
                    type: "uint8",
                    internalType: "uint8",
                  },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  {
                    name: "functionId",
                    type: "uint8",
                    internalType: "uint8",
                  },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  {
                    name: "functionId",
                    type: "uint8",
                    internalType: "uint8",
                  },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "preExecHookData", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes",
          },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      {
        name: "ownersToAdd",
        type: "address[]",
        internalType: "address[]",
      },
      {
        name: "ownersToRemove",
        type: "address[]",
        internalType: "address[]",
      },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          {
            name: "callGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "maxFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes",
          },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "event",
    name: "OwnerUpdated",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address",
      },
      {
        name: "addedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
      {
        name: "removedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "EmptyOwnersNotAllowed", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "InvalidOwner",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
  { type: "error", name: "NotAuthorized", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
  {
    type: "error",
    name: "OwnerDoesNotExist",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
] as const;
</file>

<file path="packages/core/plugins/defs/multi-owner/config.ts">
import type { PluginConfig } from "@account-kit/plugingen";
import { parseAbiParameters } from "viem";
import {
  arbitrum,
  arbitrumSepolia,
  base,
  baseSepolia,
  fraxtal,
  mainnet,
  optimism,
  optimismSepolia,
  polygon,
  polygonAmoy,
  polygonMumbai,
  sepolia,
  zora,
  zoraSepolia,
} from "viem/chains";
import { MultiOwnerPluginAbi } from "./abi";

export const MultiOwnerPluginGenConfig: PluginConfig = {
  name: "MultiOwnerPlugin",
  abi: MultiOwnerPluginAbi,
  addresses: {
    [sepolia.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [baseSepolia.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [polygon.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [polygonAmoy.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [polygonMumbai.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [optimism.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [optimismSepolia.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [arbitrum.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [arbitrumSepolia.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [base.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [fraxtal.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    2523: "0xcE0000007B008F50d762D155002600004cD6c647",
    [zora.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [zoraSepolia.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
    [mainnet.id]: "0xcE0000007B008F50d762D155002600004cD6c647",
  },
  installConfig: {
    initAbiParams: parseAbiParameters("address[]"),
  },
};
</file>

<file path="packages/core/plugins/gens/base/multi-owner/plugin.ts">
import {
  getContract,
  encodeAbiParameters,
  encodeFunctionData,
  type Address,
  type GetContractReturnType,
  type Transport,
  type PublicClient,
  type Client,
  type EncodeFunctionDataParameters,
  type Chain,
  type Hex,
  type ReadContractReturnType,
} from "viem";
import {
  ChainNotFoundError,
  AccountNotFoundError,
  isSmartAccountClient,
  IncompatibleClientError,
  type SmartContractAccount,
  type GetAccountParameter,
  type SendUserOperationResult,
  type GetEntryPointFromAccount,
  type UserOperationOverridesParameter,
  type UserOperationContext,
  type GetContextParameter,
} from "@aa-sdk/core";
import {
  installPlugin as installPlugin_,
  type Plugin,
  type FunctionReference,
} from "@account-kit/smart-contracts";

type ExecutionActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  updateOwners: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "updateOwners"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type InstallArgs = [{ type: "address[]" }];

export type InstallMultiOwnerPluginParams = {
  args: Parameters<typeof encodeAbiParameters<InstallArgs>>[1];
  pluginAddress?: Address;
  dependencyOverrides?: FunctionReference[];
};

type ManagementActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | Record<string, any>
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  installMultiOwnerPlugin: (
    args: UserOperationOverridesParameter<TEntryPointVersion> &
      InstallMultiOwnerPluginParams &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type ReadAndEncodeActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
> = {
  encodeUpdateOwners: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "updateOwners"
      >,
      "args"
    >,
  ) => Hex;

  encodeEip712Domain: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "eip712Domain"
      >,
      "args"
    >,
  ) => Hex;

  readEip712Domain: (
    args: GetAccountParameter<TAccount>,
  ) => Promise<
    ReadContractReturnType<
      typeof MultiOwnerPluginExecutionFunctionAbi,
      "eip712Domain"
    >
  >;

  encodeIsValidSignature: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "isValidSignature"
      >,
      "args"
    >,
  ) => Hex;

  readIsValidSignature: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "isValidSignature"
      >,
      "args"
    > &
      GetAccountParameter<TAccount>,
  ) => Promise<
    ReadContractReturnType<
      typeof MultiOwnerPluginExecutionFunctionAbi,
      "isValidSignature"
    >
  >;
};

export type MultiOwnerPluginActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
> = ExecutionActions<TAccount, TContext> &
  ManagementActions<TAccount, TContext> &
  ReadAndEncodeActions<TAccount>;

const addresses = {
  1: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  10: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  137: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  252: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  2523: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  8453: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  42161: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  80001: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  80002: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  84532: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  421614: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  7777777: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  11155111: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  11155420: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  999999999: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
} as Record<number, Address>;

export const MultiOwnerPlugin: Plugin<typeof MultiOwnerPluginAbi> = {
  meta: {
    name: "Multi Owner Plugin",
    version: "1.0.0",
    addresses,
  },
  getContract: <C extends Client>(
    client: C,
    address?: Address,
  ): GetContractReturnType<
    typeof MultiOwnerPluginAbi,
    PublicClient,
    Address
  > => {
    if (!client.chain) throw new ChainNotFoundError();

    return getContract({
      address: address || addresses[client.chain.id],
      abi: MultiOwnerPluginAbi,
      client: client,
    }) as GetContractReturnType<
      typeof MultiOwnerPluginAbi,
      PublicClient,
      Address
    >;
  },
};

export const multiOwnerPluginActions: <
  TTransport extends Transport = Transport,
  TChain extends Chain | undefined = Chain | undefined,
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
>(
  client: Client<TTransport, TChain, TAccount>,
) => MultiOwnerPluginActions<TAccount, TContext> = (client) => ({
  updateOwners({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "updateOwners",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "updateOwners",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  installMultiOwnerPlugin({
    account = client.account,
    overrides,
    context,
    ...params
  }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "installMultiOwnerPlugin",
        client,
      );
    }

    const chain = client.chain;
    if (!chain) {
      throw new ChainNotFoundError();
    }

    const dependencies = params.dependencyOverrides ?? [];
    const pluginAddress =
      params.pluginAddress ??
      (MultiOwnerPlugin.meta.addresses[chain.id] as Address | undefined);

    if (!pluginAddress) {
      throw new Error(
        "missing MultiOwnerPlugin address for chain " + chain.name,
      );
    }

    return installPlugin_(client, {
      pluginAddress,
      pluginInitData: encodeAbiParameters([{ type: "address[]" }], params.args),
      dependencies,
      overrides,
      account,
      context,
    });
  },
  encodeUpdateOwners({ args }) {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "updateOwners",
      args,
    });
  },
  encodeEip712Domain() {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "eip712Domain",
    });
  },

  async readEip712Domain({ account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "readEip712Domain",
        client,
      );
    }

    return client.readContract({
      address: account.address,
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "eip712Domain",
    });
  },
  encodeIsValidSignature({ args }) {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "isValidSignature",
      args,
    });
  },

  async readIsValidSignature({ args, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "readIsValidSignature",
        client,
      );
    }

    return client.readContract({
      address: account.address,
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "isValidSignature",
      args,
    });
  },
});

export const MultiOwnerPluginExecutionFunctionAbi = [
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      { name: "ownersToAdd", type: "address[]", internalType: "address[]" },
      { name: "ownersToRemove", type: "address[]", internalType: "address[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
] as const;

export const MultiOwnerPluginAbi = [
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "encodeMessageData",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getMessageHash",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isOwnerOf",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "ownerToCheck", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "ownersOf",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "preExecHookData", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      { name: "ownersToAdd", type: "address[]", internalType: "address[]" },
      { name: "ownersToRemove", type: "address[]", internalType: "address[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "event",
    name: "OwnerUpdated",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address",
      },
      {
        name: "addedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
      {
        name: "removedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "EmptyOwnersNotAllowed", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "InvalidOwner",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
  { type: "error", name: "NotAuthorized", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
  {
    type: "error",
    name: "OwnerDoesNotExist",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
] as const;
</file>

<file path="packages/core/plugins/gens/baseSepolia/multi-owner/plugin.ts">
import {
  getContract,
  encodeAbiParameters,
  encodeFunctionData,
  type Address,
  type GetContractReturnType,
  type Transport,
  type PublicClient,
  type Client,
  type EncodeFunctionDataParameters,
  type Chain,
  type Hex,
  type ReadContractReturnType,
} from "viem";
import {
  ChainNotFoundError,
  AccountNotFoundError,
  isSmartAccountClient,
  IncompatibleClientError,
  type SmartContractAccount,
  type GetAccountParameter,
  type SendUserOperationResult,
  type GetEntryPointFromAccount,
  type UserOperationOverridesParameter,
  type UserOperationContext,
  type GetContextParameter,
} from "@aa-sdk/core";
import {
  installPlugin as installPlugin_,
  type Plugin,
  type FunctionReference,
} from "@account-kit/smart-contracts";

type ExecutionActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  updateOwners: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "updateOwners"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type InstallArgs = [{ type: "address[]" }];

export type InstallMultiOwnerPluginParams = {
  args: Parameters<typeof encodeAbiParameters<InstallArgs>>[1];
  pluginAddress?: Address;
  dependencyOverrides?: FunctionReference[];
};

type ManagementActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | Record<string, any>
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  installMultiOwnerPlugin: (
    args: UserOperationOverridesParameter<TEntryPointVersion> &
      InstallMultiOwnerPluginParams &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type ReadAndEncodeActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
> = {
  encodeUpdateOwners: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "updateOwners"
      >,
      "args"
    >,
  ) => Hex;

  encodeEip712Domain: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "eip712Domain"
      >,
      "args"
    >,
  ) => Hex;

  readEip712Domain: (
    args: GetAccountParameter<TAccount>,
  ) => Promise<
    ReadContractReturnType<
      typeof MultiOwnerPluginExecutionFunctionAbi,
      "eip712Domain"
    >
  >;

  encodeIsValidSignature: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "isValidSignature"
      >,
      "args"
    >,
  ) => Hex;

  readIsValidSignature: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "isValidSignature"
      >,
      "args"
    > &
      GetAccountParameter<TAccount>,
  ) => Promise<
    ReadContractReturnType<
      typeof MultiOwnerPluginExecutionFunctionAbi,
      "isValidSignature"
    >
  >;
};

export type MultiOwnerPluginActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
> = ExecutionActions<TAccount, TContext> &
  ManagementActions<TAccount, TContext> &
  ReadAndEncodeActions<TAccount>;

const addresses = {
  1: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  10: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  137: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  252: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  2523: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  8453: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  42161: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  80001: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  80002: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  84532: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  421614: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  7777777: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  11155111: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  11155420: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  999999999: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
} as Record<number, Address>;

export const MultiOwnerPlugin: Plugin<typeof MultiOwnerPluginAbi> = {
  meta: {
    name: "Multi Owner Plugin",
    version: "1.0.0",
    addresses,
  },
  getContract: <C extends Client>(
    client: C,
    address?: Address,
  ): GetContractReturnType<
    typeof MultiOwnerPluginAbi,
    PublicClient,
    Address
  > => {
    if (!client.chain) throw new ChainNotFoundError();

    return getContract({
      address: address || addresses[client.chain.id],
      abi: MultiOwnerPluginAbi,
      client: client,
    }) as GetContractReturnType<
      typeof MultiOwnerPluginAbi,
      PublicClient,
      Address
    >;
  },
};

export const multiOwnerPluginActions: <
  TTransport extends Transport = Transport,
  TChain extends Chain | undefined = Chain | undefined,
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
>(
  client: Client<TTransport, TChain, TAccount>,
) => MultiOwnerPluginActions<TAccount, TContext> = (client) => ({
  updateOwners({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "updateOwners",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "updateOwners",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  installMultiOwnerPlugin({
    account = client.account,
    overrides,
    context,
    ...params
  }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "installMultiOwnerPlugin",
        client,
      );
    }

    const chain = client.chain;
    if (!chain) {
      throw new ChainNotFoundError();
    }

    const dependencies = params.dependencyOverrides ?? [];
    const pluginAddress =
      params.pluginAddress ??
      (MultiOwnerPlugin.meta.addresses[chain.id] as Address | undefined);

    if (!pluginAddress) {
      throw new Error(
        "missing MultiOwnerPlugin address for chain " + chain.name,
      );
    }

    return installPlugin_(client, {
      pluginAddress,
      pluginInitData: encodeAbiParameters([{ type: "address[]" }], params.args),
      dependencies,
      overrides,
      account,
      context,
    });
  },
  encodeUpdateOwners({ args }) {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "updateOwners",
      args,
    });
  },
  encodeEip712Domain() {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "eip712Domain",
    });
  },

  async readEip712Domain({ account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "readEip712Domain",
        client,
      );
    }

    return client.readContract({
      address: account.address,
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "eip712Domain",
    });
  },
  encodeIsValidSignature({ args }) {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "isValidSignature",
      args,
    });
  },

  async readIsValidSignature({ args, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "readIsValidSignature",
        client,
      );
    }

    return client.readContract({
      address: account.address,
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "isValidSignature",
      args,
    });
  },
});

export const MultiOwnerPluginExecutionFunctionAbi = [
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      { name: "ownersToAdd", type: "address[]", internalType: "address[]" },
      { name: "ownersToRemove", type: "address[]", internalType: "address[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
] as const;

export const MultiOwnerPluginAbi = [
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "encodeMessageData",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getMessageHash",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isOwnerOf",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "ownerToCheck", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "ownersOf",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "preExecHookData", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      { name: "ownersToAdd", type: "address[]", internalType: "address[]" },
      { name: "ownersToRemove", type: "address[]", internalType: "address[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "event",
    name: "OwnerUpdated",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address",
      },
      {
        name: "addedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
      {
        name: "removedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "EmptyOwnersNotAllowed", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "InvalidOwner",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
  { type: "error", name: "NotAuthorized", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
  {
    type: "error",
    name: "OwnerDoesNotExist",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
] as const;
</file>

<file path="packages/core/plugins/gens/sepolia/multi-owner/plugin.ts">
import {
  getContract,
  encodeAbiParameters,
  encodeFunctionData,
  type Address,
  type GetContractReturnType,
  type Transport,
  type PublicClient,
  type Client,
  type EncodeFunctionDataParameters,
  type Chain,
  type Hex,
  type ReadContractReturnType,
} from "viem";
import {
  ChainNotFoundError,
  AccountNotFoundError,
  isSmartAccountClient,
  IncompatibleClientError,
  type SmartContractAccount,
  type GetAccountParameter,
  type SendUserOperationResult,
  type GetEntryPointFromAccount,
  type UserOperationOverridesParameter,
  type UserOperationContext,
  type GetContextParameter,
} from "@aa-sdk/core";
import {
  installPlugin as installPlugin_,
  type Plugin,
  type FunctionReference,
} from "@account-kit/smart-contracts";

type ExecutionActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  updateOwners: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "updateOwners"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type InstallArgs = [{ type: "address[]" }];

export type InstallMultiOwnerPluginParams = {
  args: Parameters<typeof encodeAbiParameters<InstallArgs>>[1];
  pluginAddress?: Address;
  dependencyOverrides?: FunctionReference[];
};

type ManagementActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | Record<string, any>
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  installMultiOwnerPlugin: (
    args: UserOperationOverridesParameter<TEntryPointVersion> &
      InstallMultiOwnerPluginParams &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type ReadAndEncodeActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
> = {
  encodeUpdateOwners: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "updateOwners"
      >,
      "args"
    >,
  ) => Hex;

  encodeEip712Domain: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "eip712Domain"
      >,
      "args"
    >,
  ) => Hex;

  readEip712Domain: (
    args: GetAccountParameter<TAccount>,
  ) => Promise<
    ReadContractReturnType<
      typeof MultiOwnerPluginExecutionFunctionAbi,
      "eip712Domain"
    >
  >;

  encodeIsValidSignature: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "isValidSignature"
      >,
      "args"
    >,
  ) => Hex;

  readIsValidSignature: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof MultiOwnerPluginExecutionFunctionAbi,
        "isValidSignature"
      >,
      "args"
    > &
      GetAccountParameter<TAccount>,
  ) => Promise<
    ReadContractReturnType<
      typeof MultiOwnerPluginExecutionFunctionAbi,
      "isValidSignature"
    >
  >;
};

export type MultiOwnerPluginActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
> = ExecutionActions<TAccount, TContext> &
  ManagementActions<TAccount, TContext> &
  ReadAndEncodeActions<TAccount>;

const addresses = {
  1: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  10: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  137: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  252: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  2523: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  8453: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  42161: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  80001: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  80002: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  84532: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  421614: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  7777777: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  11155111: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  11155420: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
  999999999: "0xcE0000007B008F50d762D155002600004cD6c647" as Address,
} as Record<number, Address>;

export const MultiOwnerPlugin: Plugin<typeof MultiOwnerPluginAbi> = {
  meta: {
    name: "Multi Owner Plugin",
    version: "1.0.0",
    addresses,
  },
  getContract: <C extends Client>(
    client: C,
    address?: Address,
  ): GetContractReturnType<
    typeof MultiOwnerPluginAbi,
    PublicClient,
    Address
  > => {
    if (!client.chain) throw new ChainNotFoundError();

    return getContract({
      address: address || addresses[client.chain.id],
      abi: MultiOwnerPluginAbi,
      client: client,
    }) as GetContractReturnType<
      typeof MultiOwnerPluginAbi,
      PublicClient,
      Address
    >;
  },
};

export const multiOwnerPluginActions: <
  TTransport extends Transport = Transport,
  TChain extends Chain | undefined = Chain | undefined,
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
>(
  client: Client<TTransport, TChain, TAccount>,
) => MultiOwnerPluginActions<TAccount, TContext> = (client) => ({
  updateOwners({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "updateOwners",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "updateOwners",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  installMultiOwnerPlugin({
    account = client.account,
    overrides,
    context,
    ...params
  }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "installMultiOwnerPlugin",
        client,
      );
    }

    const chain = client.chain;
    if (!chain) {
      throw new ChainNotFoundError();
    }

    const dependencies = params.dependencyOverrides ?? [];
    const pluginAddress =
      params.pluginAddress ??
      (MultiOwnerPlugin.meta.addresses[chain.id] as Address | undefined);

    if (!pluginAddress) {
      throw new Error(
        "missing MultiOwnerPlugin address for chain " + chain.name,
      );
    }

    return installPlugin_(client, {
      pluginAddress,
      pluginInitData: encodeAbiParameters([{ type: "address[]" }], params.args),
      dependencies,
      overrides,
      account,
      context,
    });
  },
  encodeUpdateOwners({ args }) {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "updateOwners",
      args,
    });
  },
  encodeEip712Domain() {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "eip712Domain",
    });
  },

  async readEip712Domain({ account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "readEip712Domain",
        client,
      );
    }

    return client.readContract({
      address: account.address,
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "eip712Domain",
    });
  },
  encodeIsValidSignature({ args }) {
    return encodeFunctionData({
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "isValidSignature",
      args,
    });
  },

  async readIsValidSignature({ args, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "readIsValidSignature",
        client,
      );
    }

    return client.readContract({
      address: account.address,
      abi: MultiOwnerPluginExecutionFunctionAbi,
      functionName: "isValidSignature",
      args,
    });
  },
});

export const MultiOwnerPluginExecutionFunctionAbi = [
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      { name: "ownersToAdd", type: "address[]", internalType: "address[]" },
      { name: "ownersToRemove", type: "address[]", internalType: "address[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
] as const;

export const MultiOwnerPluginAbi = [
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "encodeMessageData",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getMessageHash",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "message", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isOwnerOf",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "ownerToCheck", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isValidSignature",
    inputs: [
      { name: "digest", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "ownersOf",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "preExecHookData", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "updateOwners",
    inputs: [
      { name: "ownersToAdd", type: "address[]", internalType: "address[]" },
      { name: "ownersToRemove", type: "address[]", internalType: "address[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "event",
    name: "OwnerUpdated",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address",
      },
      {
        name: "addedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
      {
        name: "removedOwners",
        type: "address[]",
        indexed: false,
        internalType: "address[]",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "EmptyOwnersNotAllowed", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "InvalidOwner",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
  { type: "error", name: "NotAuthorized", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
  {
    type: "error",
    name: "OwnerDoesNotExist",
    inputs: [{ name: "owner", type: "address", internalType: "address" }],
  },
] as const;
</file>

<file path="packages/examples/bridge-and-split/.gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="packages/examples/bridge-and-split/tsconfig.json">
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["esnext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="packages/examples/swap-and-split/.gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="packages/examples/swap-and-split/README.md">
# swap-and-split

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.2.5. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.
</file>

<file path="packages/examples/swap-and-split/tsconfig.json">
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["esnext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="contracts/foundry.toml">
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
remappings = [
    "@modular-account=lib/modular-account/src",
    "@openzeppelin=lib/openzeppelin-contracts"
    ]

# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options
</file>

<file path="packages/core/tsconfig.json">
{
  // This tsconfig file contains the shared config for the build (tsconfig.build.json) and type checking (tsconfig.json) config.
  "include": [
    "./"
  ],
  "compilerOptions": {
    // Incremental builds
    // NOTE: Enabling incremental builds speeds up `tsc`. Keep in mind though that it does not reliably bust the cache when the `tsconfig.json` file changes.
    "incremental": false,
    // Type checking
    "strict": true,
    "useDefineForClassFields": true, // Not enabled by default in `strict` mode unless we bump `target` to ES2022.
    "noFallthroughCasesInSwitch": true, // Not enabled by default in `strict` mode.
    "noImplicitReturns": true, // Not enabled by default in `strict` mode.
    "useUnknownInCatchVariables": true, // TODO: This would normally be enabled in `strict` mode but would require some adjustments to the codebase.
    "noImplicitOverride": true, // Not enabled by default in `strict` mode.
    "noUnusedLocals": true, // Not enabled by default in `strict` mode.
    "noUnusedParameters": true, // Not enabled by default in `strict` mode.
    // TODO: The following options are also not enabled by default in `strict` mode and would be nice to have but would require some adjustments to the codebase.
    // "exactOptionalPropertyTypes": true,
    // "noUncheckedIndexedAccess": true,
    // JavaScript support
    "allowJs": false,
    "checkJs": false,
    // Interop constraints
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": false,
    "forceConsistentCasingInFileNames": true,
    "verbatimModuleSyntax": true,
    "importHelpers": true, // This is only used for build validation. Since we do not have `tslib` installed, this will fail if we accidentally make use of anything that'd require injection of helpers.
    // Language and environment
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "module": "NodeNext",
    "target": "ES2021", // Setting this to `ES2021` enables native support for `Node v16+`: https://github.com/microsoft/TypeScript/wiki/Node-Target-Mapping.
    "lib": [
      "ES2022", // By using ES2022 we get access to the `.cause` property on `Error` instances.
      "DOM" // We are adding `DOM` here to get the `fetch`, etc. types. This should be removed once these types are available via DefinitelyTyped.
    ],
    // Skip type checking for node modules
    "skipLibCheck": true,
    "types": [
      "bun-types"
    ],
    "sourceMap": true,
    "rootDir": "./",
    "baseUrl": "./"
  }
}
</file>

<file path="packages/examples/swap-and-split/erc20-to-erc20.ts">
import {
    OrderBookApi,
    OrderKind,
    SigningScheme,
    type UnsignedOrder,
    BuyTokenDestination,
    MAX_VALID_TO_EPOCH,
    SellTokenSource,
    OrderSigningUtils,
    buildAppData
} from '@cowprotocol/cow-sdk';
import type { Order, OrderBalance } from "@cowprotocol/contracts";
import * as dotenv from "dotenv";
import { LocalAccountSigner } from "@aa-sdk/core";
import { base } from "@account-kit/infra";
import {
    keccak256,
    toHex,
    encodeAbiParameters,
    type Address,
    maxUint256,
} from "viem";
import { createLockerSplitClient, EChain } from '@locker-labs/sdk';

dotenv.config();

// Get configuration from environment variables
const PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;
if (!PRIVATE_KEY) {
    throw new Error("PRIVATE_KEY is not set");
}

const ALCHEMY_API_KEY = process.env.ALCHEMY_API_KEY as string;
if (!ALCHEMY_API_KEY) {
    throw new Error("ALCHEMY_API_KEY is not set");
}

const RPC_URL = process.env.RPC_URL as string;
if (!RPC_URL) {
    throw new Error("RPC_URL is not set");
}

// CoW Protocol's GPv2Settlement contract on Sepolia
const GPV2_SETTLEMENT = "0x9008D19f58AAbD9eD0D60971565AA8510560ab41";
const GPV2_VAULT_RELAYER = "0xC92E8bdf79f0507f65a392b0ab4667716BFE0110" as Address; // Vault Relayer on Sepolia

// Example tokens on Sepolia
const USDC_SEPOLIA = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
const WETH_SEPOLIA = "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14";

const USDC_BASE = "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913"
const WETH_BASE = "0x4200000000000000000000000000000000000006"
const chain = base
const eChain = EChain.BASE

const sendToken = WETH_BASE
const sellAmount = "1000000000111"; // 0.000001 ETH

const buyToken = USDC_BASE
const buyAmount = "10"; // Adjust based on the price you want

const chainId = chain.id

// Split config
const splitRecipients = [
    "0xd7F723f8EDeC8D6D62caa4Ecc2b5Ca1292618355",
    "0x1ECF3f51A771983C150b3cB4A2162E89c0A046Fc"
] as Address[];
const splitPercentages = [95, 5];

/*
 * Implementation
 */

// Create a Locker Client
const salt = 0n;
const splitClient = await createLockerSplitClient({
    salt,
    alchemyApiKey: ALCHEMY_API_KEY,
    chain: eChain,
    signer: LocalAccountSigner.privateKeyToAccountSigner(
        PRIVATE_KEY as Address
    ),
});
// Smart account itself receives the tokens after swap
const splitClientAddress = splitClient.getAddress();
console.log(`Locker Client (${salt}) created: ${splitClientAddress}`);

// One time configuration of Locker Split Client
await splitClient.setupSplit(
    buyToken,
    splitPercentages,
    splitRecipients
);

// Set token allowance
console.log(`Checking allowance for token ${sendToken} to spender ${GPV2_VAULT_RELAYER}...`);
const selector = keccak256(toHex('approve(address,uint256)')).slice(0, 10);
const suffixData = encodeAbiParameters(
    [
        { name: "spender", type: "address" },
        { name: "amount", type: "uint256" },
    ],
    [GPV2_VAULT_RELAYER, maxUint256]
);
const approvalData = selector + suffixData.slice(2);

const result = await splitClient.sendUserOps(sendToken, approvalData as Address, BigInt(0));
console.log(`Approval userOp hash: ${result.hash}`);

// sleep for 10 seconds, so userOp has time to settle
console.log(`Sleeping for a few seconds so userOp has time to settle...`);
await new Promise(resolve => setTimeout(resolve, 10_000));

// Create a COW Protocol OrderBookApi
const orderBookApi = new OrderBookApi({
    chainId: chain.id,
    env: 'prod' // Use 'staging' for testnets
});

const appDataInfo = await buildAppData({
    appCode: 'CoW Swap', // Use an appropriate app code
    orderClass: 'limit',
    slippageBps: 0,
});

// Create an unsigned order
const orderToSign: UnsignedOrder = {
    receiver: splitClientAddress,
    sellToken: sendToken,
    buyToken,
    sellAmount,
    buyAmount,
    validTo: MAX_VALID_TO_EPOCH,
    feeAmount: "0", // Fee is determined by the protocol
    kind: OrderKind.SELL,
    partiallyFillable: false,
    sellTokenBalance: SellTokenSource.ERC20,
    buyTokenBalance: BuyTokenDestination.ERC20,
    signingScheme: SigningScheme.PRESIGN,
    appData: appDataInfo.appDataKeccak256
};

// Generate orderId using the smart account address as the owner
const { orderDigest, orderId } = await OrderSigningUtils.generateOrderId(
    chainId,
    {
        ...orderToSign,
        sellTokenBalance: orderToSign.sellTokenBalance as string as OrderBalance,
        buyTokenBalance: orderToSign.buyTokenBalance as string as OrderBalance,
    } as Order,
    {
        owner: splitClientAddress
    }
);
console.log("Order Digest:", orderDigest);
console.log("Order ID:", orderId);

// Create the order in the orderbook with the PRESIGN scheme
const orderCreation = {
    ...orderToSign,
    from: splitClientAddress,
    signature: splitClientAddress, // For PRESIGN, signature is the sender address
    signingScheme: SigningScheme.PRESIGN,
    appData: appDataInfo.fullAppData, // Use the full app data JSON
    appDataHash: appDataInfo.appDataKeccak256 // Use the hash for appDataHash field
};
console.log("Order Creation:", orderCreation);

// Send the order to the order book
const createdOrderId = await orderBookApi.sendOrder(orderCreation);
console.log("Created Order ID:", createdOrderId);

// Prepare presign data
const preSignSelector = keccak256(toHex('setPreSignature(bytes,bool)')).slice(0, 10);
const preSignParams = encodeAbiParameters(
    [
        { name: "orderUid", type: "bytes" },
        { name: "signed", type: "bool" },
    ],
    [createdOrderId as Address, true]
);
const preSignData = preSignSelector + preSignParams.slice(2);

// Send the presign userOp
const preSignResult = await splitClient.sendUserOps(
    GPV2_SETTLEMENT,
    preSignData as Address,
    BigInt(0)
);
console.log(`Presign userOp hash: ${preSignResult.hash}`);

// sleep for 10 seconds, so userOp has time to settle
console.log(`Sleeping for a few seconds so userOp has time to settle...`);
await new Promise(resolve => setTimeout(resolve, 10_000));

// Check the order status
const order = await orderBookApi.getOrder(createdOrderId);
console.log("Order status:", order.status);
</file>

<file path="packages/examples/swap-and-split/eth-to-erc20.ts">
import {
    OrderBookApi,
    OrderKind,
    SigningScheme,
    SupportedChainId,
    type UnsignedOrder,
    BuyTokenDestination,
    MAX_VALID_TO_EPOCH,
    SellTokenSource,
    OrderSigningUtils,
    WRAPPED_NATIVE_CURRENCIES,
    buildAppData
} from '@cowprotocol/cow-sdk';
import type { Order, OrderBalance } from "@cowprotocol/contracts";
import * as dotenv from "dotenv";
import { createModularAccountAlchemyClient } from "@account-kit/smart-contracts";
import { LocalAccountSigner } from "@aa-sdk/core";
import { alchemy, base, sepolia } from "@account-kit/infra";
import {
    encodeFunctionData,
    parseAbi,
    keccak256,
    toHex,
    encodeAbiParameters,
    type Address,
    maxUint256,
    http,
    createPublicClient
} from "viem";
import { createLockerSplitClient, EChain } from '@locker-labs/sdk';

dotenv.config();

// Get configuration from environment variables
const PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;
if (!PRIVATE_KEY) {
    throw new Error("PRIVATE_KEY is not set");
}

const ALCHEMY_API_KEY = process.env.ALCHEMY_API_KEY as string;
if (!ALCHEMY_API_KEY) {
    throw new Error("ALCHEMY_API_KEY is not set");
}

const RPC_URL = process.env.RPC_URL as string;
if (!RPC_URL) {
    throw new Error("RPC_URL is not set");
}

// CoW Protocol's GPv2Settlement contract on Sepolia
const GPV2_SETTLEMENT = "0x9008D19f58AAbD9eD0D60971565AA8510560ab41";
const GPV2_VAULT_RELAYER = "0xC92E8bdf79f0507f65a392b0ab4667716BFE0110" as Address; // Vault Relayer on Sepolia

// Example tokens on Sepolia
const USDC_SEPOLIA = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
const WETH_SEPOLIA = "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14";

const USDC_BASE = "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913"
const WETH_BASE = "0x4200000000000000000000000000000000000006"
const chain = base
const eChain = EChain.BASE

const sendToken = WETH_BASE
const sellAmount = "1000000001111"; // 0.000001 ETH

const buyToken = USDC_BASE
const buyAmount = "10"; // Adjust based on the price you want

const chainId = chain.id

// Split config
const splitRecipients = [
    "0xd7F723f8EDeC8D6D62caa4Ecc2b5Ca1292618355",
    "0x1ECF3f51A771983C150b3cB4A2162E89c0A046Fc"
] as Address[];
const splitPercentages = [95, 5];

/*
 * Implementation
 */

// Create a Locker Client
const salt = 0n;
const splitClient = await createLockerSplitClient({
    salt,
    alchemyApiKey: ALCHEMY_API_KEY,
    chain: eChain,
    signer: LocalAccountSigner.privateKeyToAccountSigner(
        PRIVATE_KEY as Address
    ),
});
// Smart account itself receives the tokens after swap
const splitClientAddress = splitClient.getAddress();
console.log(`Locker Client (${salt}) created: ${splitClientAddress}`);

// One time configuration of Locker Split Client
await splitClient.setupSplit(
    buyToken,
    splitPercentages,
    splitRecipients
);

// First, convert ETH to WETH by calling the deposit function
console.log(`Converting ${sellAmount} ETH to WETH...`);

// Define WETH deposit ABI
const wethDepositAbi = parseAbi([
    "function deposit() payable"
]);

// Encode the deposit function call
const depositData = encodeFunctionData({
    abi: wethDepositAbi,
    functionName: 'deposit'
});

// Send deposit userOp to WETH contract with ETH value
const depositResult = await splitClient.sendUserOps(
    sendToken,
    depositData as Address,
    BigInt(sellAmount)
);
console.log(`Deposit userOp hash: ${depositResult.hash}`);

// Sleep for 10 seconds, so userOp has time to settle
console.log(`Sleeping for a few seconds so deposit has time to settle...`);
await new Promise(resolve => setTimeout(resolve, 10_000));

// Now proceed with token allowance
console.log(`Setting allowance for WETH to spender ${GPV2_VAULT_RELAYER}...`);
const selector = keccak256(toHex('approve(address,uint256)')).slice(0, 10);
const suffixData = encodeAbiParameters(
    [
        { name: "spender", type: "address" },
        { name: "amount", type: "uint256" },
    ],
    [GPV2_VAULT_RELAYER, maxUint256]
);
const approvalData = selector + suffixData.slice(2);

const result = await splitClient.sendUserOps(sendToken, approvalData as Address, BigInt(0));
console.log(`Approval userOp hash: ${result.hash}`);

// sleep for 10 seconds, so userOp has time to settle
console.log(`Sleeping for a few seconds so userOp has time to settle...`);
await new Promise(resolve => setTimeout(resolve, 10_000));

// Create a COW Protocol OrderBookApi
const orderBookApi = new OrderBookApi({
    chainId: chain.id,
    env: 'prod' // Use 'staging' for testnets
});

const appDataInfo = await buildAppData({
    appCode: 'CoW Swap', // Use an appropriate app code
    orderClass: 'limit',
    slippageBps: 0,
});

// Create an unsigned order
const orderToSign: UnsignedOrder = {
    receiver: splitClientAddress,
    sellToken: sendToken,
    buyToken,
    sellAmount,
    buyAmount,
    validTo: MAX_VALID_TO_EPOCH,
    feeAmount: "0", // Fee is determined by the protocol
    kind: OrderKind.SELL,
    partiallyFillable: false,
    sellTokenBalance: SellTokenSource.ERC20,
    buyTokenBalance: BuyTokenDestination.ERC20,
    signingScheme: SigningScheme.PRESIGN,
    appData: appDataInfo.appDataKeccak256
};

// Generate orderId using the smart account address as the owner
const { orderDigest, orderId } = await OrderSigningUtils.generateOrderId(
    chainId,
    {
        ...orderToSign,
        sellTokenBalance: orderToSign.sellTokenBalance as string as OrderBalance,
        buyTokenBalance: orderToSign.buyTokenBalance as string as OrderBalance,
    } as Order,
    {
        owner: splitClientAddress
    }
);
console.log("Order Digest:", orderDigest);
console.log("Order ID:", orderId);

// Create the order in the orderbook with the PRESIGN scheme
const orderCreation = {
    ...orderToSign,
    from: splitClientAddress,
    signature: splitClientAddress, // For PRESIGN, signature is the sender address
    signingScheme: SigningScheme.PRESIGN,
    appData: appDataInfo.fullAppData, // Use the full app data JSON
    appDataHash: appDataInfo.appDataKeccak256 // Use the hash for appDataHash field
};
console.log("Order Creation:", orderCreation);

// Send the order to the order book
const createdOrderId = await orderBookApi.sendOrder(orderCreation);
console.log("Created Order ID:", createdOrderId);

// Prepare presign data
const preSignSelector = keccak256(toHex('setPreSignature(bytes,bool)')).slice(0, 10);
const preSignParams = encodeAbiParameters(
    [
        { name: "orderUid", type: "bytes" },
        { name: "signed", type: "bool" },
    ],
    [createdOrderId as Address, true]
);
const preSignData = preSignSelector + preSignParams.slice(2);

// Send the presign userOp
const preSignResult = await splitClient.sendUserOps(
    GPV2_SETTLEMENT,
    preSignData as Address,
    BigInt(0)
);
console.log(`Presign userOp hash: ${preSignResult.hash}`);

// sleep for 10 seconds, so userOp has time to settle
console.log(`Sleeping for a few seconds so userOp has time to settle...`);
await new Promise(resolve => setTimeout(resolve, 10_000));

// Check the order status
const order = await orderBookApi.getOrder(createdOrderId);
console.log("Order status:", order.status);
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

_cjs
_esm
_types
*.local
.DS_Store
.eslintcache
.next
bench
cache
coverage
node_modules
tsconfig*.tsbuildinfo
esbuild-why-permissionless*

# local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.envrc
</file>

<file path=".gitmodules">
[submodule "contracts/lib/openzeppelin-contracts"]
	path = contracts/lib/openzeppelin-contracts
	url = https://github.com/OpenZeppelin/openzeppelin-contracts
[submodule "contracts/lib/modular-account"]
	path = contracts/lib/modular-account
	url = https://github.com/alchemyplatform/modular-account
	branch = v1.0.x
</file>

<file path="packages/core/bridge/impl.ts">
import type { ILockerSplitClient } from '../plugins/index.js';
import { cctpBridgeTokenFromSolana, cctpReceiveTokenFromSolana, type ICctpBridgeFromSolanaResponse } from './providers/cctp/cctpBridge.js';
import type { IBridgeFromSolanaParams, IBridgeFromSolanaResponse, IBridgeName } from './types.js';

/**
 * Bridges a token from Solana to another chain.
 */
export async function bridgeTokenFromSolana(bridgeFromSolanaParams: IBridgeFromSolanaParams): Promise<IBridgeFromSolanaResponse> {
    const { bridgeName } = bridgeFromSolanaParams;
    if (bridgeName === 'cctp') {
        return cctpBridgeTokenFromSolana(bridgeFromSolanaParams);
    }

    throw new Error(`Unsupported bridge: ${bridgeName}`);
}

/**
 * Receives a token bridged from Solana to another chain.
 */
export async function receiveTokenFromSolana(
    bridgeName: IBridgeName,
    bridgeFromSolanaResponse: IBridgeFromSolanaResponse,
    splitsClient: ILockerSplitClient,
) {
    if (bridgeName === 'cctp') {
        return cctpReceiveTokenFromSolana(bridgeFromSolanaResponse as ICctpBridgeFromSolanaResponse, splitsClient);
    }

    throw new Error(`Unsupported bridge: ${bridgeName}`);
}

/**
 * Bridges a token from Solana and receives on destination chain.
 */
export async function bridgeAndReceiveTokenFromSolana(
    bridgeFromSolanaParams: IBridgeFromSolanaParams
) {
    const { bridgeName, lockerClient } = bridgeFromSolanaParams;

    if (bridgeName === 'cctp') {
        const response: ICctpBridgeFromSolanaResponse = await cctpBridgeTokenFromSolana(bridgeFromSolanaParams);
        console.log('Bridge response:', response);

        return cctpReceiveTokenFromSolana(response, lockerClient);
    }

    throw new Error(`Unsupported bridge: ${bridgeName}`);
}
</file>

<file path="packages/core/plugins/defs/split/abi.ts">
export const SplitPluginAbi = [
  {
    type: "function",
    name: "AUTHOR",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "NAME",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "VERSION",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "getSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "percentages", type: "uint32[]", internalType: "uint32[]" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getSplitIndexes",
    inputs: [{ name: "_user", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "uint256[]", internalType: "uint256[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isSplitCreator",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitCreator", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "manifest",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "splitConfigCount",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigIndexes",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigs",
    inputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      {
        name: "",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "pure",
  },
  {
    type: "event",
    name: "AutomationSwitched",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
      {
        name: "currentState",
        type: "bool",
        indexed: false,
        internalType: "bool",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigCreated",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigDeleted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitExecuted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
] as const;
</file>

<file path="packages/core/plugins/defs/split/config.ts">
import type { PluginConfig } from "@account-kit/plugingen";
import { type Address, parseAbiParameters } from "viem";
import { base, baseSepolia, sepolia } from "viem/chains";
import { MultiOwnerPluginGenConfig } from "../multi-owner/config.js";
import { SplitPluginAbi } from "./abi.js";

export const SPLIT_PLUGIN_SEPOLIA =
  "0x12438c60e855ca58C34b1b2780d208D733D370CF" as Address;

export const SPLIT_PLUGIN_BASE =
  "0x2a4f50188850660D2C7D411EdA120CBb5D9A3EE4" as Address;

export const SPLIT_PLUGIN_BASE_SEPOLIA =
  "0x400932DCddAc89bEA6F2C261dA7aC1C427BdBf5b" as Address;

export const chainToSplitPluginAddress: Record<number, Address> = {
  [sepolia.id]: SPLIT_PLUGIN_SEPOLIA,
  [base.id]: SPLIT_PLUGIN_BASE,
  [baseSepolia.id]: SPLIT_PLUGIN_BASE_SEPOLIA,
};

export const SplitPluginGenConfig: PluginConfig = {
  name: "SplitPlugin",
  abi: SplitPluginAbi,
  addresses: {
    [sepolia.id]: SPLIT_PLUGIN_SEPOLIA,
    [base.id]: SPLIT_PLUGIN_BASE,
    [baseSepolia.id]: SPLIT_PLUGIN_BASE_SEPOLIA,
  },
  installConfig: {
    initAbiParams: parseAbiParameters(
      "address tokenAddess, address[] splitAddresses, uint256[] percentages"
    ),

    dependencies: [
      {
        plugin: MultiOwnerPluginGenConfig,
        functionId: "0x0",
      },
      {
        plugin: MultiOwnerPluginGenConfig,
        functionId: "0x1",
      },
    ],
  },
};
</file>

<file path="packages/core/plugins/gens/base/split/plugin.ts">
import {
  getContract,
  encodePacked,
  encodeAbiParameters,
  encodeFunctionData,
  type Address,
  type GetContractReturnType,
  type Transport,
  type PublicClient,
  type Client,
  type EncodeFunctionDataParameters,
  type Chain,
  type Hex,
} from "viem";
import {
  ChainNotFoundError,
  AccountNotFoundError,
  isSmartAccountClient,
  IncompatibleClientError,
  type SmartContractAccount,
  type GetAccountParameter,
  type SendUserOperationResult,
  type GetEntryPointFromAccount,
  type UserOperationOverridesParameter,
  type UserOperationContext,
  type GetContextParameter,
} from "@aa-sdk/core";
import {
  installPlugin as installPlugin_,
  type Plugin,
  type FunctionReference,
} from "@account-kit/smart-contracts";
import { MultiOwnerPlugin } from "../multi-owner/plugin.js";

type ExecutionActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  createSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "createSplit"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  toggleIsSplitEnabled: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "toggleIsSplitEnabled"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  split: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "split"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  updateSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "updateSplitConfig"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  deleteSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "deleteSplitConfig"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type InstallArgs = [
  { type: "address"; name: "tokenAddess" },
  { type: "address[]"; name: "splitAddresses" },
  { type: "uint256[]"; name: "percentages" },
];

export type InstallSplitPluginParams = {
  args: Parameters<typeof encodeAbiParameters<InstallArgs>>[1];
  pluginAddress?: Address;
  dependencyOverrides?: FunctionReference[];
};

type ManagementActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | Record<string, any>
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  installSplitPlugin: (
    args: UserOperationOverridesParameter<TEntryPointVersion> &
      InstallSplitPluginParams &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type ReadAndEncodeActions = {
  encodeCreateSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "createSplit"
      >,
      "args"
    >,
  ) => Hex;

  encodeToggleIsSplitEnabled: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "toggleIsSplitEnabled"
      >,
      "args"
    >,
  ) => Hex;

  encodeSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "split"
      >,
      "args"
    >,
  ) => Hex;

  encodeUpdateSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "updateSplitConfig"
      >,
      "args"
    >,
  ) => Hex;

  encodeDeleteSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "deleteSplitConfig"
      >,
      "args"
    >,
  ) => Hex;
};

export type SplitPluginActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
> = ExecutionActions<TAccount, TContext> &
  ManagementActions<TAccount, TContext> &
  ReadAndEncodeActions;

const addresses = {
  8453: "0x2a4f50188850660D2C7D411EdA120CBb5D9A3EE4" as Address,
  84532: "0x400932DCddAc89bEA6F2C261dA7aC1C427BdBf5b" as Address,
  11155111: "0x12438c60e855ca58C34b1b2780d208D733D370CF" as Address,
} as Record<number, Address>;

export const SplitPlugin: Plugin<typeof SplitPluginAbi> = {
  meta: {
    name: "Split Plugin",
    version: "0.0.1",
    addresses,
  },
  getContract: <C extends Client>(
    client: C,
    address?: Address,
  ): GetContractReturnType<typeof SplitPluginAbi, PublicClient, Address> => {
    if (!client.chain) throw new ChainNotFoundError();

    return getContract({
      address: address || addresses[client.chain.id],
      abi: SplitPluginAbi,
      client: client,
    }) as GetContractReturnType<typeof SplitPluginAbi, PublicClient, Address>;
  },
};

export const splitPluginActions: <
  TTransport extends Transport = Transport,
  TChain extends Chain | undefined = Chain | undefined,
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
>(
  client: Client<TTransport, TChain, TAccount>,
) => SplitPluginActions<TAccount, TContext> = (client) => ({
  createSplit({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "createSplit",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "createSplit",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  toggleIsSplitEnabled({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "toggleIsSplitEnabled",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "toggleIsSplitEnabled",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  split({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError("SmartAccountClient", "split", client);
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "split",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  updateSplitConfig({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "updateSplitConfig",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "updateSplitConfig",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  deleteSplitConfig({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "deleteSplitConfig",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "deleteSplitConfig",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  installSplitPlugin({
    account = client.account,
    overrides,
    context,
    ...params
  }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "installSplitPlugin",
        client,
      );
    }

    const chain = client.chain;
    if (!chain) {
      throw new ChainNotFoundError();
    }

    const dependencies = params.dependencyOverrides ?? [
      (() => {
        const pluginAddress = MultiOwnerPlugin.meta.addresses[chain.id];
        if (!pluginAddress) {
          throw new Error(
            "missing MultiOwnerPlugin address for chain " + chain.name,
          );
        }

        return encodePacked(["address", "uint8"], [pluginAddress, 0x0]);
      })(),

      (() => {
        const pluginAddress = MultiOwnerPlugin.meta.addresses[chain.id];
        if (!pluginAddress) {
          throw new Error(
            "missing MultiOwnerPlugin address for chain " + chain.name,
          );
        }

        return encodePacked(["address", "uint8"], [pluginAddress, 0x1]);
      })(),
    ];
    const pluginAddress =
      params.pluginAddress ??
      (SplitPlugin.meta.addresses[chain.id] as Address | undefined);

    if (!pluginAddress) {
      throw new Error("missing SplitPlugin address for chain " + chain.name);
    }

    return installPlugin_(client, {
      pluginAddress,
      pluginInitData: encodeAbiParameters(
        [
          { type: "address", name: "tokenAddess" },
          { type: "address[]", name: "splitAddresses" },
          { type: "uint256[]", name: "percentages" },
        ],
        params.args,
      ),
      dependencies,
      overrides,
      account,
      context,
    });
  },
  encodeCreateSplit({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "createSplit",
      args,
    });
  },
  encodeToggleIsSplitEnabled({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "toggleIsSplitEnabled",
      args,
    });
  },
  encodeSplit({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "split",
      args,
    });
  },
  encodeUpdateSplitConfig({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "updateSplitConfig",
      args,
    });
  },
  encodeDeleteSplitConfig({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "deleteSplitConfig",
      args,
    });
  },
});

export const SplitPluginExecutionFunctionAbi = [
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
] as const;

export const SplitPluginAbi = [
  {
    type: "function",
    name: "AUTHOR",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "NAME",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "VERSION",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "getSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "percentages", type: "uint32[]", internalType: "uint32[]" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getSplitIndexes",
    inputs: [{ name: "_user", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "uint256[]", internalType: "uint256[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isSplitCreator",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitCreator", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "manifest",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "splitConfigCount",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigIndexes",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigs",
    inputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      {
        name: "",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "pure",
  },
  {
    type: "event",
    name: "AutomationSwitched",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
      {
        name: "currentState",
        type: "bool",
        indexed: false,
        internalType: "bool",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigCreated",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigDeleted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitExecuted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
] as const;
</file>

<file path="packages/core/plugins/gens/baseSepolia/split/plugin.ts">
import {
  getContract,
  encodePacked,
  encodeAbiParameters,
  encodeFunctionData,
  type Address,
  type GetContractReturnType,
  type Transport,
  type PublicClient,
  type Client,
  type EncodeFunctionDataParameters,
  type Chain,
  type Hex,
} from "viem";
import {
  ChainNotFoundError,
  AccountNotFoundError,
  isSmartAccountClient,
  IncompatibleClientError,
  type SmartContractAccount,
  type GetAccountParameter,
  type SendUserOperationResult,
  type GetEntryPointFromAccount,
  type UserOperationOverridesParameter,
  type UserOperationContext,
  type GetContextParameter,
} from "@aa-sdk/core";
import {
  installPlugin as installPlugin_,
  type Plugin,
  type FunctionReference,
} from "@account-kit/smart-contracts";
import { MultiOwnerPlugin } from "../multi-owner/plugin.js";

type ExecutionActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  createSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "createSplit"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  toggleIsSplitEnabled: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "toggleIsSplitEnabled"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  split: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "split"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  updateSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "updateSplitConfig"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  deleteSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "deleteSplitConfig"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type InstallArgs = [
  { type: "address"; name: "tokenAddess" },
  { type: "address[]"; name: "splitAddresses" },
  { type: "uint256[]"; name: "percentages" },
];

export type InstallSplitPluginParams = {
  args: Parameters<typeof encodeAbiParameters<InstallArgs>>[1];
  pluginAddress?: Address;
  dependencyOverrides?: FunctionReference[];
};

type ManagementActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | Record<string, any>
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  installSplitPlugin: (
    args: UserOperationOverridesParameter<TEntryPointVersion> &
      InstallSplitPluginParams &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type ReadAndEncodeActions = {
  encodeCreateSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "createSplit"
      >,
      "args"
    >,
  ) => Hex;

  encodeToggleIsSplitEnabled: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "toggleIsSplitEnabled"
      >,
      "args"
    >,
  ) => Hex;

  encodeSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "split"
      >,
      "args"
    >,
  ) => Hex;

  encodeUpdateSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "updateSplitConfig"
      >,
      "args"
    >,
  ) => Hex;

  encodeDeleteSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "deleteSplitConfig"
      >,
      "args"
    >,
  ) => Hex;
};

export type SplitPluginActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
> = ExecutionActions<TAccount, TContext> &
  ManagementActions<TAccount, TContext> &
  ReadAndEncodeActions;

const addresses = {
  8453: "0x2a4f50188850660D2C7D411EdA120CBb5D9A3EE4" as Address,
  84532: "0x400932DCddAc89bEA6F2C261dA7aC1C427BdBf5b" as Address,
  11155111: "0x12438c60e855ca58C34b1b2780d208D733D370CF" as Address,
} as Record<number, Address>;

export const SplitPlugin: Plugin<typeof SplitPluginAbi> = {
  meta: {
    name: "Split Plugin",
    version: "0.0.1",
    addresses,
  },
  getContract: <C extends Client>(
    client: C,
    address?: Address,
  ): GetContractReturnType<typeof SplitPluginAbi, PublicClient, Address> => {
    if (!client.chain) throw new ChainNotFoundError();

    return getContract({
      address: address || addresses[client.chain.id],
      abi: SplitPluginAbi,
      client: client,
    }) as GetContractReturnType<typeof SplitPluginAbi, PublicClient, Address>;
  },
};

export const splitPluginActions: <
  TTransport extends Transport = Transport,
  TChain extends Chain | undefined = Chain | undefined,
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
>(
  client: Client<TTransport, TChain, TAccount>,
) => SplitPluginActions<TAccount, TContext> = (client) => ({
  createSplit({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "createSplit",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "createSplit",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  toggleIsSplitEnabled({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "toggleIsSplitEnabled",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "toggleIsSplitEnabled",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  split({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError("SmartAccountClient", "split", client);
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "split",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  updateSplitConfig({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "updateSplitConfig",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "updateSplitConfig",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  deleteSplitConfig({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "deleteSplitConfig",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "deleteSplitConfig",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  installSplitPlugin({
    account = client.account,
    overrides,
    context,
    ...params
  }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "installSplitPlugin",
        client,
      );
    }

    const chain = client.chain;
    if (!chain) {
      throw new ChainNotFoundError();
    }

    const dependencies = params.dependencyOverrides ?? [
      (() => {
        const pluginAddress = MultiOwnerPlugin.meta.addresses[chain.id];
        if (!pluginAddress) {
          throw new Error(
            "missing MultiOwnerPlugin address for chain " + chain.name,
          );
        }

        return encodePacked(["address", "uint8"], [pluginAddress, 0x0]);
      })(),

      (() => {
        const pluginAddress = MultiOwnerPlugin.meta.addresses[chain.id];
        if (!pluginAddress) {
          throw new Error(
            "missing MultiOwnerPlugin address for chain " + chain.name,
          );
        }

        return encodePacked(["address", "uint8"], [pluginAddress, 0x1]);
      })(),
    ];
    const pluginAddress =
      params.pluginAddress ??
      (SplitPlugin.meta.addresses[chain.id] as Address | undefined);

    if (!pluginAddress) {
      throw new Error("missing SplitPlugin address for chain " + chain.name);
    }

    return installPlugin_(client, {
      pluginAddress,
      pluginInitData: encodeAbiParameters(
        [
          { type: "address", name: "tokenAddess" },
          { type: "address[]", name: "splitAddresses" },
          { type: "uint256[]", name: "percentages" },
        ],
        params.args,
      ),
      dependencies,
      overrides,
      account,
      context,
    });
  },
  encodeCreateSplit({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "createSplit",
      args,
    });
  },
  encodeToggleIsSplitEnabled({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "toggleIsSplitEnabled",
      args,
    });
  },
  encodeSplit({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "split",
      args,
    });
  },
  encodeUpdateSplitConfig({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "updateSplitConfig",
      args,
    });
  },
  encodeDeleteSplitConfig({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "deleteSplitConfig",
      args,
    });
  },
});

export const SplitPluginExecutionFunctionAbi = [
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
] as const;

export const SplitPluginAbi = [
  {
    type: "function",
    name: "AUTHOR",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "NAME",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "VERSION",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "getSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "percentages", type: "uint32[]", internalType: "uint32[]" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getSplitIndexes",
    inputs: [{ name: "_user", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "uint256[]", internalType: "uint256[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isSplitCreator",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitCreator", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "manifest",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "splitConfigCount",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigIndexes",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigs",
    inputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      {
        name: "",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "pure",
  },
  {
    type: "event",
    name: "AutomationSwitched",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
      {
        name: "currentState",
        type: "bool",
        indexed: false,
        internalType: "bool",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigCreated",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigDeleted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitExecuted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
] as const;
</file>

<file path="packages/core/plugins/gens/sepolia/split/plugin.ts">
import {
  getContract,
  encodePacked,
  encodeAbiParameters,
  encodeFunctionData,
  type Address,
  type GetContractReturnType,
  type Transport,
  type PublicClient,
  type Client,
  type EncodeFunctionDataParameters,
  type Chain,
  type Hex,
} from "viem";
import {
  ChainNotFoundError,
  AccountNotFoundError,
  isSmartAccountClient,
  IncompatibleClientError,
  type SmartContractAccount,
  type GetAccountParameter,
  type SendUserOperationResult,
  type GetEntryPointFromAccount,
  type UserOperationOverridesParameter,
  type UserOperationContext,
  type GetContextParameter,
} from "@aa-sdk/core";
import {
  installPlugin as installPlugin_,
  type Plugin,
  type FunctionReference,
} from "@account-kit/smart-contracts";
import { MultiOwnerPlugin } from "../multi-owner/plugin.js";

type ExecutionActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  createSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "createSplit"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  toggleIsSplitEnabled: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "toggleIsSplitEnabled"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  split: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "split"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  updateSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "updateSplitConfig"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;

  deleteSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "deleteSplitConfig"
      >,
      "args"
    > &
      UserOperationOverridesParameter<TEntryPointVersion> &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type InstallArgs = [
  { type: "address"; name: "tokenAddess" },
  { type: "address[]"; name: "splitAddresses" },
  { type: "uint256[]"; name: "percentages" },
];

export type InstallSplitPluginParams = {
  args: Parameters<typeof encodeAbiParameters<InstallArgs>>[1];
  pluginAddress?: Address;
  dependencyOverrides?: FunctionReference[];
};

type ManagementActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | Record<string, any>
    | undefined,
  TEntryPointVersion extends
    GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>,
> = {
  installSplitPlugin: (
    args: UserOperationOverridesParameter<TEntryPointVersion> &
      InstallSplitPluginParams &
      GetAccountParameter<TAccount> &
      GetContextParameter<TContext>,
  ) => Promise<SendUserOperationResult<TEntryPointVersion>>;
};

type ReadAndEncodeActions = {
  encodeCreateSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "createSplit"
      >,
      "args"
    >,
  ) => Hex;

  encodeToggleIsSplitEnabled: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "toggleIsSplitEnabled"
      >,
      "args"
    >,
  ) => Hex;

  encodeSplit: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "split"
      >,
      "args"
    >,
  ) => Hex;

  encodeUpdateSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "updateSplitConfig"
      >,
      "args"
    >,
  ) => Hex;

  encodeDeleteSplitConfig: (
    args: Pick<
      EncodeFunctionDataParameters<
        typeof SplitPluginExecutionFunctionAbi,
        "deleteSplitConfig"
      >,
      "args"
    >,
  ) => Hex;
};

export type SplitPluginActions<
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
> = ExecutionActions<TAccount, TContext> &
  ManagementActions<TAccount, TContext> &
  ReadAndEncodeActions;

const addresses = {
  8453: "0x2a4f50188850660D2C7D411EdA120CBb5D9A3EE4" as Address,
  84532: "0x400932DCddAc89bEA6F2C261dA7aC1C427BdBf5b" as Address,
  11155111: "0x12438c60e855ca58C34b1b2780d208D733D370CF" as Address,
} as Record<number, Address>;

export const SplitPlugin: Plugin<typeof SplitPluginAbi> = {
  meta: {
    name: "Split Plugin",
    version: "0.0.1",
    addresses,
  },
  getContract: <C extends Client>(
    client: C,
    address?: Address,
  ): GetContractReturnType<typeof SplitPluginAbi, PublicClient, Address> => {
    if (!client.chain) throw new ChainNotFoundError();

    return getContract({
      address: address || addresses[client.chain.id],
      abi: SplitPluginAbi,
      client: client,
    }) as GetContractReturnType<typeof SplitPluginAbi, PublicClient, Address>;
  },
};

export const splitPluginActions: <
  TTransport extends Transport = Transport,
  TChain extends Chain | undefined = Chain | undefined,
  TAccount extends SmartContractAccount | undefined =
    | SmartContractAccount
    | undefined,
  TContext extends UserOperationContext | undefined =
    | UserOperationContext
    | undefined,
>(
  client: Client<TTransport, TChain, TAccount>,
) => SplitPluginActions<TAccount, TContext> = (client) => ({
  createSplit({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "createSplit",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "createSplit",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  toggleIsSplitEnabled({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "toggleIsSplitEnabled",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "toggleIsSplitEnabled",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  split({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError("SmartAccountClient", "split", client);
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "split",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  updateSplitConfig({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "updateSplitConfig",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "updateSplitConfig",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  deleteSplitConfig({ args, overrides, context, account = client.account }) {
    if (!account) {
      throw new AccountNotFoundError();
    }
    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "deleteSplitConfig",
        client,
      );
    }

    const uo = encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "deleteSplitConfig",
      args,
    });

    return client.sendUserOperation({ uo, overrides, account, context });
  },
  installSplitPlugin({
    account = client.account,
    overrides,
    context,
    ...params
  }) {
    if (!account) {
      throw new AccountNotFoundError();
    }

    if (!isSmartAccountClient(client)) {
      throw new IncompatibleClientError(
        "SmartAccountClient",
        "installSplitPlugin",
        client,
      );
    }

    const chain = client.chain;
    if (!chain) {
      throw new ChainNotFoundError();
    }

    const dependencies = params.dependencyOverrides ?? [
      (() => {
        const pluginAddress = MultiOwnerPlugin.meta.addresses[chain.id];
        if (!pluginAddress) {
          throw new Error(
            "missing MultiOwnerPlugin address for chain " + chain.name,
          );
        }

        return encodePacked(["address", "uint8"], [pluginAddress, 0x0]);
      })(),

      (() => {
        const pluginAddress = MultiOwnerPlugin.meta.addresses[chain.id];
        if (!pluginAddress) {
          throw new Error(
            "missing MultiOwnerPlugin address for chain " + chain.name,
          );
        }

        return encodePacked(["address", "uint8"], [pluginAddress, 0x1]);
      })(),
    ];
    const pluginAddress =
      params.pluginAddress ??
      (SplitPlugin.meta.addresses[chain.id] as Address | undefined);

    if (!pluginAddress) {
      throw new Error("missing SplitPlugin address for chain " + chain.name);
    }

    return installPlugin_(client, {
      pluginAddress,
      pluginInitData: encodeAbiParameters(
        [
          { type: "address", name: "tokenAddess" },
          { type: "address[]", name: "splitAddresses" },
          { type: "uint256[]", name: "percentages" },
        ],
        params.args,
      ),
      dependencies,
      overrides,
      account,
      context,
    });
  },
  encodeCreateSplit({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "createSplit",
      args,
    });
  },
  encodeToggleIsSplitEnabled({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "toggleIsSplitEnabled",
      args,
    });
  },
  encodeSplit({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "split",
      args,
    });
  },
  encodeUpdateSplitConfig({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "updateSplitConfig",
      args,
    });
  },
  encodeDeleteSplitConfig({ args }) {
    return encodeFunctionData({
      abi: SplitPluginExecutionFunctionAbi,
      functionName: "deleteSplitConfig",
      args,
    });
  },
});

export const SplitPluginExecutionFunctionAbi = [
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
] as const;

export const SplitPluginAbi = [
  {
    type: "function",
    name: "AUTHOR",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "NAME",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "VERSION",
    inputs: [],
    outputs: [{ name: "", type: "string", internalType: "string" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "createSplit",
    inputs: [
      { name: "_tokenAddress", type: "address", internalType: "address" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "deleteSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "getSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "percentages", type: "uint32[]", internalType: "uint32[]" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "getSplitIndexes",
    inputs: [{ name: "_user", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "uint256[]", internalType: "uint256[]" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "isSplitCreator",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitCreator", type: "address", internalType: "address" },
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "pluginManifest",
    inputs: [],
    outputs: [
      {
        name: "manifest",
        type: "tuple",
        internalType: "struct PluginManifest",
        components: [
          { name: "interfaceIds", type: "bytes4[]", internalType: "bytes4[]" },
          {
            name: "dependencyInterfaceIds",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "executionFunctions",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permittedExecutionSelectors",
            type: "bytes4[]",
            internalType: "bytes4[]",
          },
          {
            name: "permitAnyExternalAddress",
            type: "bool",
            internalType: "bool",
          },
          { name: "canSpendNativeToken", type: "bool", internalType: "bool" },
          {
            name: "permittedExternalCalls",
            type: "tuple[]",
            internalType: "struct ManifestExternalCallPermission[]",
            components: [
              {
                name: "externalAddress",
                type: "address",
                internalType: "address",
              },
              { name: "permitAnySelector", type: "bool", internalType: "bool" },
              { name: "selectors", type: "bytes4[]", internalType: "bytes4[]" },
            ],
          },
          {
            name: "userOpValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "runtimeValidationFunctions",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preUserOpValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "preRuntimeValidationHooks",
            type: "tuple[]",
            internalType: "struct ManifestAssociatedFunction[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "associatedFunction",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
          {
            name: "executionHooks",
            type: "tuple[]",
            internalType: "struct ManifestExecutionHook[]",
            components: [
              {
                name: "executionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "preExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
              {
                name: "postExecHook",
                type: "tuple",
                internalType: "struct ManifestFunction",
                components: [
                  {
                    name: "functionType",
                    type: "uint8",
                    internalType: "enum ManifestAssociatedFunctionType",
                  },
                  { name: "functionId", type: "uint8", internalType: "uint8" },
                  {
                    name: "dependencyIndex",
                    type: "uint256",
                    internalType: "uint256",
                  },
                ],
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "pluginMetadata",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct PluginMetadata",
        components: [
          { name: "name", type: "string", internalType: "string" },
          { name: "version", type: "string", internalType: "string" },
          { name: "author", type: "string", internalType: "string" },
          {
            name: "permissionDescriptors",
            type: "tuple[]",
            internalType: "struct SelectorPermission[]",
            components: [
              {
                name: "functionSelector",
                type: "bytes4",
                internalType: "bytes4",
              },
              {
                name: "permissionDescription",
                type: "string",
                internalType: "string",
              },
            ],
          },
        ],
      },
    ],
    stateMutability: "pure",
  },
  {
    type: "function",
    name: "postExecutionHook",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      { name: "", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preExecutionHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preRuntimeValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "preUserOpValidationHook",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "runtimeValidationFunction",
    inputs: [
      { name: "functionId", type: "uint8", internalType: "uint8" },
      { name: "sender", type: "address", internalType: "address" },
      { name: "value", type: "uint256", internalType: "uint256" },
      { name: "data", type: "bytes", internalType: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "split",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "splitConfigCount",
    inputs: [],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigIndexes",
    inputs: [
      { name: "", type: "address", internalType: "address" },
      { name: "", type: "uint256", internalType: "uint256" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "splitConfigs",
    inputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    outputs: [
      { name: "tokenAddress", type: "address", internalType: "address" },
      { name: "isSplitEnabled", type: "bool", internalType: "bool" },
    ],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [{ name: "interfaceId", type: "bytes4", internalType: "bytes4" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view",
  },
  {
    type: "function",
    name: "toggleIsSplitEnabled",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "updateSplitConfig",
    inputs: [
      { name: "_configIndex", type: "uint256", internalType: "uint256" },
      { name: "_splitAddresses", type: "address[]", internalType: "address[]" },
      { name: "_percentages", type: "uint32[]", internalType: "uint32[]" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    type: "function",
    name: "userOpValidationFunction",
    inputs: [
      { name: "", type: "uint8", internalType: "uint8" },
      {
        name: "",
        type: "tuple",
        internalType: "struct UserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          { name: "callGasLimit", type: "uint256", internalType: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256",
            internalType: "uint256",
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "maxFeePerGas", type: "uint256", internalType: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256",
            internalType: "uint256",
          },
          { name: "paymasterAndData", type: "bytes", internalType: "bytes" },
          { name: "signature", type: "bytes", internalType: "bytes" },
        ],
      },
      { name: "", type: "bytes32", internalType: "bytes32" },
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "pure",
  },
  {
    type: "event",
    name: "AutomationSwitched",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
      {
        name: "currentState",
        type: "bool",
        indexed: false,
        internalType: "bool",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigCreated",
    inputs: [
      { name: "user", type: "address", indexed: true, internalType: "address" },
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitConfigDeleted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  {
    type: "event",
    name: "SplitExecuted",
    inputs: [
      {
        name: "configIndex",
        type: "uint256",
        indexed: true,
        internalType: "uint256",
      },
    ],
    anonymous: false,
  },
  { type: "error", name: "AlreadyInitialized", inputs: [] },
  { type: "error", name: "InvalidAction", inputs: [] },
  {
    type: "error",
    name: "NotContractCaller",
    inputs: [{ name: "caller", type: "address", internalType: "address" }],
  },
  {
    type: "error",
    name: "NotImplemented",
    inputs: [
      { name: "selector", type: "bytes4", internalType: "bytes4" },
      { name: "functionId", type: "uint8", internalType: "uint8" },
    ],
  },
  { type: "error", name: "NotInitialized", inputs: [] },
] as const;
</file>

<file path="packages/core/plugins/utils/helpers.ts">
import { chainToSplitPluginAddress } from "../defs/split/config";

async function isSplitPluginInstalled(
  extendedAccount: any,
  chainId: number
): Promise<boolean> {
  const splitPluginAddress = chainToSplitPluginAddress[chainId];
  const installedPlugins = await extendedAccount.getInstalledPlugins({});
  if (!installedPlugins.includes(splitPluginAddress)) {
    return false;
  }
  return true;
}

export { isSplitPluginInstalled };
</file>

<file path="packages/examples/bridge-and-split/package.json">
{
  "name": "bridge-and-split",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@aa-sdk/core": "^4.20.1",
    "@aa-sdk/ethers": "^4.20.1",
    "@account-kit/infra": "^4.20.1",
    "@account-kit/smart-contracts": "^4.20.1",
    "@alchemy/aa-accounts": "^3.19.0",
    "@locker-labs/sdk": "workspace:*",
    "alchemy-sdk": "^3.5.5",
    "bs58": "^6.0.0"
  }
}
</file>

<file path="packages/examples/bridge-and-split/README.md">
# bridge-and-split

Bridge 0.01 USDC from Solana Devnet to Base Sepolia. Then split the token using Locker Split Plugin.

```bash
bun install
```

To run:

```bash
cp .env.example .env
bun run index.ts
```
</file>

<file path="packages/examples/swap-and-split/package.json">
{
  "name": "swap-and-split",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@aa-sdk/core": "^4.20.1",
    "@aa-sdk/ethers": "^4.20.1",
    "@account-kit/infra": "^4.20.1",
    "@account-kit/smart-contracts": "^4.20.1",
    "@alchemy/aa-accounts": "^3.19.0",
    "@cowprotocol/app-data": "^2.5.1",
    "@cowprotocol/contracts": "^1.7.0",
    "@cowprotocol/cow-sdk": "^5.10.2",
    "@locker-labs/sdk": "workspace:*",
    "alchemy-sdk": "^3.5.5",
    "dotenv": "^16.4.7",
    "repomix": "^0.3.1",
    "viem": "^2.24.1"
  }
}
</file>

<file path="packages/core/accounts/types.ts">
import { type Address } from "viem";
import { LocalAccountSigner } from "@aa-sdk/core";

import type { EChain } from "./tokens.js";

export interface ILockerClientParams {
  alchemyApiKey: string; // Used for the Alchemy transport.
  chain: EChain;
  signer: ReturnType<typeof LocalAccountSigner.privateKeyToAccountSigner>;
  merchantSeed1?: string;
  salt?: bigint;
}

export enum EPlugins {
  SAVINGS_PLUGIN = "savings_plugin",
  SPLIT_PLUGIN = "split_plugin",
}

/**
 * Interface representing the LockerClient.
 * This is the client returned by createLockerClient.
 */
export type ILockerClient = {
  /**
   * Extend the client with a plugin that adds extra functionality.
   * @param plugin - An object containing additional functions.
   * @returns The extended client.
   */
  getAddress: () => Address;
  isPluginInstalled: (plugin: Address) => Promise<boolean>;
  extend: (pluginActions: any) => any;
  installPlugin: (plugin: Address) => Promise<any>;
  uninstallPlugin: (plugin: Address) => Promise<any>;
  sendUserOps: (to: Address, data: Address, value: bigint) => Promise<any>;
}
</file>

<file path="packages/core/README.md">
## Getting Started
```zsh
bun add @locker-labs/sdk
```

## Usage
```ts
import { createLockerClient } from "@locker-labs/sdk";

const message = createLockerClient()
console.log(message)
```

## Development
```zsh
# Install dependencies  
bun install

# Build the package
bun run build

# Publish the package
bun publish --access public
```

### Generating a plugin actions file
- Create a config file, refer to splits/def/splitPluginConfig.
- Update plugingen.config.ts to refer to the added config file.
- Then run command:
```zsh 
bunx plugingen generate 
```
</file>

<file path="packages/examples/bridge-and-split/.env.example">
# Base58 encoded private key
SOLANA_PRIVATE_KEY_BS58=
SOLANA_RPC_URL=https://api.devnet.solana.com

# Private key with 0x prefix (bridge token recipient chain)
EVM_PRIVATE_KEY=
ALCHEMY_API_KEY=
</file>

<file path="packages/core/accounts/impl.ts">
import { alchemy } from "@account-kit/infra";
import { createModularAccountAlchemyClient } from "@account-kit/smart-contracts";

import type { ILockerClientParams, ILockerClient } from "./types.js";
import { adaptLockerChain2AlchemyChain } from "./helpers.js";

/**
 * Validates the input parameters for creating the client.
 */
function validateClientParams(params: ILockerClientParams): void {
  if (!params.alchemyApiKey || params.alchemyApiKey.trim() === "") {
    throw new Error(
      "Invalid parameter: 'apiKey' is required and cannot be empty."
    );
  }
  if (!params.chain) {
    throw new Error("Invalid parameter: 'chain' is required.");
  }
  if (!params.signer) {
    throw new Error(
      "Invalid configuration: No signer provided and no default PRIVATE KEY found in environment."
    );
  }
}

/**
 * Creates a locker modular account client without any plugins.
 * Users can later install plugins onto this client using installPlugin.
 *
 * @param params - The configuration parameters for creating the client.
 * @returns A promise that resolves to the locker modular account client.
 */
export async function createLockerClient(
  params: ILockerClientParams
): Promise<ILockerClient> {
  validateClientParams(params);

  const { alchemyApiKey: apiKey, chain: lockerChain, signer, salt } = params;

  const chain = adaptLockerChain2AlchemyChain(lockerChain);

  const aaClient = await createModularAccountAlchemyClient({
    salt: salt ? salt : BigInt(0),
    signer,
    chain,
    transport: alchemy({ apiKey }),
  });

  const lockerClient: ILockerClient = {
    getAddress: () => aaClient.getAddress(),

    isPluginInstalled: async (plugin) => {
      const installedPlugins = await aaClient.getInstalledPlugins({});
      if (!installedPlugins.includes(plugin)) {
        return false;
      }
      return true;
    },

    extend: (pluginActions) => aaClient.extend(pluginActions) as ILockerClient,

    installPlugin: async (plugin) => {
      return await aaClient.installPlugin({
        pluginAddress: plugin,
      });
    },

    uninstallPlugin: async (plugin) => {
      return await aaClient.uninstallPlugin({ pluginAddress: plugin });
    },

    sendUserOps: async (to, data, value) => {
      return await aaClient.sendUserOperation({
        uo: {
          target: to,
          data,
          value,
        },
      });
    },
  };

  return lockerClient as ILockerClient;
}
</file>

<file path="packages/core/plugingen.config.ts">
import { defineConfig } from "@account-kit/plugingen";
import { SplitPluginGenConfig } from "./plugins/defs/split/config";
import { MultiOwnerPluginGenConfig } from "./plugins/defs/multi-owner/config";
import { base, sepolia, baseSepolia } from "viem/chains";
import * as dotenv from "dotenv";

dotenv.config();

export default defineConfig([
  {
    outDir: "./plugins/gens/base",
    chain: base,
    rpcUrl: process.env.BASE_RPC as string,
    plugins: [MultiOwnerPluginGenConfig, SplitPluginGenConfig],
  },
  {
    outDir: "./plugins/gens/sepolia",
    chain: sepolia,
    rpcUrl: process.env.SEPOLIA_RPC as string,
    plugins: [MultiOwnerPluginGenConfig, SplitPluginGenConfig],
  },
  {
    outDir: "./plugins/gens/baseSepolia",
    chain: baseSepolia,
    rpcUrl: process.env.BASE_SEPOLIA_RPC as string,
    plugins: [MultiOwnerPluginGenConfig, SplitPluginGenConfig],
  },
]);
</file>

<file path="package.json">
{
  "workspaces": [
    "packages/core",
    "packages/examples/bridge-and-split",
    "packages/examples/swap-and-split"
  ],
  "version": "0.0.1",
  "private": true,
  "author": "Locker",
  "type": "module",
  "sideEffects": false,
  "devDependencies": {},
  "description": "",
  "keywords": [],
  "license": "MIT",
  "scripts": {},
  "simple-git-hooks": {
    "pre-commit": "bun run format && bun run lint:fix"
  }
}
</file>

<file path="README.md">
# Locker SDK

Locker makes plugins that you can install into your account abstraction wallet to enable advanced features like token splits, savings, swapping, bridging, and yield. Locker uses ERC-6900 modules, enabling compatibility with any ERC-4337 wallet that supports the standard. Currently Circle and Alchemy are the main wallets that support ERC-6900 modules.

## SplitPlugin

The split plugin lets your wallet automatically split up it's token balance between multiple destination accounts. This can be used to collect fees from users, distribute royalties, treasury management, airdrop allocations, and more.

### Quickstart

Install dependencies:
```sh
npm install @locker-labs/sdk bs58 viem @solana/web3.js @aa-sdk/core
```

Create smart account that divides all USDC deposits between two recipient addresses:
```ts
import {
  bridgeAndReceiveTokenFromSolana,
  USDC,
  createLockerSplitClient,
  type IBridgeName,
  EChain,
} from "@locker-labs/sdk";

const chain = EChain.sepolia

// Create a Split Client
const splitClient = await createLockerSplitClient({
    salt: BigInt(1),
    alchemyApiKey: ALCHEMY_API_KEY,
    chain,
    signer: LocalAccountSigner.privateKeyToAccountSigner(
        EVM_PRIVATE_KEY as Address
    ),
});

// Install Split Plugin
await splitClient.installSplitPlugin();

// When USDC is sent to Split Plugin:
// 95% goes to 0xA, 5% goes to 0xB
await splitClient.createSplit(
    USDC[EChain.sepolia],
    [95, 5],
    ["0xA", "0xB"]
);

// Get the address of your Split Plugin
const recipientAddress = splitClient.getAddress();
console.log(`Splits address: ${recipientAddress}`);
```

### Sample flows
The real power of the Split Plugin comes when you combine it with other functionaliy. We have provided several sample projects that show you how to use our SDK to create some interesting flows.

Working examples for these flows can be found in [packages/examples](./packages/examples).

- Bridge and split: Bridge a token from one chain to another then split the funds between multiple wallets.
- Swap and split (coming soon): Swap a token for something else then split the funds between multiple wallets.

## Project structure
This is a monorepo that contains the smart contracts for the actual modules, as well as a Typescript SDK to help you integrate these modules into your wallet.

- [contracts](./contracts) - ERC6900 modules used by SDK.
- [core](./packages/core) - Core package for Locker SDK.

## Supported chains

- Plugins: Any EVM chain. Currently deployed to EthereumSepolia and Base Mainnet. 
- Bridging: Any chain supported by CCTP. Currently assuming Solana is the source chain.

Contact us to get your chain added. (@locker_money)[https://twitter.com/locker_money]
</file>

<file path="contracts/README.md">
# Locker Labs Contracts

This repository contains the smart contracts for Locker Labs. The Split Plugin, that extend functionality and automate token management.

## Plugins

### Split Plugin
Allows users to split token transfers among multiple recipients automatically, simplifying fund distribution.

- Base: [0x2a4f50188850660D2C7D411EdA120CBb5D9A3EE4](https://basescan.org/address/0x2a4f50188850660D2C7D411EdA120CBb5D9A3EE4)

- Sepolia: [0x12438c60e855ca58C34b1b2780d208D733D370CF](https://sepolia.etherscan.io/address/0x12438c60e855ca58C34b1b2780d208D733D370CF)

- Base Sepolia: [0x400932DCddAc89bEA6F2C261dA7aC1C427BdBf5b](https://base-sepolia.blockscout.com/address/0x400932DCddAc89bEA6F2C261dA7aC1C427BdBf5b)
</file>

<file path="packages/core/bridge/index.ts">
export * from "./impl.js";
export * from "./types.js";
export * from "./providers/cctp/cctpBridge.js";
export * from "./providers/cctp/cctpConstants.js";
export * from "./providers/cctp/cctpUtils.js";
</file>

<file path="packages/core/bridge/types.ts">
import type { Keypair } from "@solana/web3.js";
import type { EChain } from "../accounts/tokens.js";
import type { ILockerClient } from "../accounts/types.js";

export type ISolanaNetwork = "devnet" | "mainnet";

/**
 * The bridging provider identifier.
 */
export type IBridgeName = 'cctp';

export type IBridgeFromSolanaParams = {
    solanaSigner: Keypair;
    solanaTokenAddress: string;
    solanaRpcUrl: string;
    amount: number;
    recipientChain: EChain;
    recipientAddress: string;
    solanaChain: EChain;
    bridgeName: IBridgeName;
    lockerClient: ILockerClient;
}

export type IBridgeFromSolanaResponse = {
    depositTx: string;
    reclaimTx?: string;
    recipientChain: EChain;
}
</file>

<file path="packages/core/accounts/index.ts">
export * from "./impl.js";
export * from "./types.js";
export * from "./helpers.js";
export * from "./tokens.js";
</file>

<file path="packages/core/plugins/index.ts">
import { type Address, createPublicClient, http } from "viem";

import {
  createLockerClient,
} from "../accounts/impl.js";
import { splitPluginActions as baseSplitPluginActions } from "./gens/base/split/plugin.js";
import { splitPluginActions as sepoliaSplitPluginActions } from "./gens/sepolia/split/plugin.js";
import { splitPluginActions as baseSepoliaSplitPluginActions } from "./gens/baseSepolia/split/plugin.js";
import { isSplitPluginInstalled } from "./utils/helpers.js";
import { chainToSplitPluginAddress } from "./defs/split/config.js";
import { base, baseSepolia, sepolia } from "@account-kit/infra";
import { adaptLockerChain2AlchemyChain, waitForTransaction } from "../accounts/helpers.js";
import { SplitPluginAbi } from "./defs/split/abi.js";
import type { ILockerClient, ILockerClientParams } from "../accounts/types.js";

export interface ILockerSplitClient extends ILockerClient {
  getAddress: () => Address;

  getConfigs: () => Promise<bigint[]>;

  createSplit: (
    tokenAddress: Address,
    percentage: bigint[],
    receiverAddresses: Address[]
  ) => Promise<any>;

  installSplitPlugin: (
    tokenAddress: Address,
    percentages: bigint[],
    receiverAddresses: Address[]
  ) => Promise<any>;

  isSplitPluginInstalled: () => Promise<boolean>;

  uninstallSplitPlugin: () => Promise<any>;

  toggleIsSplitEnabled: (configIndex: number) => Promise<any>;

  split: (configIndex: number) => Promise<any>;

  deleteSplit: (configIndex: bigint) => Promise<any>;
}

/**
 * Creates a Locker Split Client that the end user interacts with.
 * It takes in all necessary parameters to build the extended client, then wraps it to expose only selected functions.
 *
 * @param params - The configuration parameters(ExtendedClientParams) for creating the client.
 * @returns A promise that resolves to a LockerSplitClient.
 */
export async function createLockerSplitClient(
  params: ILockerClientParams
): Promise<ILockerSplitClient> {
  const lockerClient = await createLockerClient(params);
  const { chain: lockerChain, alchemyApiKey } = params;

  const chain = adaptLockerChain2AlchemyChain(lockerChain);
  const chainId = chain.id;

  let splitPluginActions;
  switch (chainId) {
    case base.id:
      splitPluginActions = baseSplitPluginActions;
      break;
    case baseSepolia.id:
      splitPluginActions = baseSepoliaSplitPluginActions;
      break;
    case sepolia.id:
      splitPluginActions = sepoliaSplitPluginActions;
      break;
    default:
      throw new Error(`Unsupported chain: ${chain.id}`);
  }

  const splitLockerClient = await lockerClient.extend(splitPluginActions);
  const alchemyRpcUrl = `${chain.rpcUrls.alchemy.http[0]}/${alchemyApiKey}`;

  const client = createPublicClient({
    chain,
    transport: http(alchemyRpcUrl),
  });

  return {
    ...lockerClient,
    async getConfigs(): Promise<bigint[]> {
      if (!(await isSplitPluginInstalled(splitLockerClient, chainId))) {
        console.log("Split plugin not installed.");
        return [];
      }
      const globalIndexes = [];
      // Get all the global indexes, Max possible 5.
      // TODO: Replace with a query.
      for (let i = 0; i < 5; i++) {
        let globalIndex;
        try {
          globalIndex = await client.readContract({
            address: chainToSplitPluginAddress[chain.id],
            abi: SplitPluginAbi,
            functionName: "splitConfigIndexes",
            args: [await splitLockerClient.getAddress(), BigInt(i)],
          });
          globalIndexes.push(globalIndex);
        } catch {
          break;
        }
      }
      return globalIndexes;
    },
    async createSplit(
      tokenAddress: string,
      percentage: bigint[],
      receiverAddresses: string[]
    ): Promise<any> {
      if (!(await isSplitPluginInstalled(splitLockerClient, chainId))) {
        console.log("Split plugin not installed.");
        return null;
      }

      console.log("Creating Split Config...");
      const res = await splitLockerClient.createSplit({
        args: [tokenAddress, receiverAddresses, percentage],
      });
      console.log("Waiting for creation confirmation...");
      await waitForTransaction(res.hash, alchemyRpcUrl);
      console.log("Split config created:", res);
      return res;
    },

    async installSplitPlugin(
      tokenAddress,
      percentages,
      splitAddresses
    ): Promise<any> {
      if (await isSplitPluginInstalled(splitLockerClient, chainId)) {
        console.log("Split plugin already installed.");
        return null;
      }

      console.log("Installing Split Plugin...");
      const res = await splitLockerClient.installSplitPlugin({
        args: [tokenAddress, splitAddresses, percentages],
      });

      console.log("Waiting for installation confirmation...");
      await waitForTransaction(res.hash, alchemyRpcUrl);
      console.log("Split plugin installed with:", res);

      return res;
    },

    async isSplitPluginInstalled(): Promise<boolean> {
      return await isSplitPluginInstalled(splitLockerClient, chainId);
    },

    async uninstallSplitPlugin(): Promise<any> {
      if (!(await isSplitPluginInstalled(splitLockerClient, chainId))) {
        console.log("Split plugin not installed.");
        return null;
      }

      console.log("Uninstalling Split Plugin...");
      const res = await splitLockerClient.uninstallPlugin({
        pluginAddress: chainToSplitPluginAddress[chain.id],
      });

      console.log("Waiting for uninstallation confirmation...");
      await waitForTransaction(res.hash, alchemyRpcUrl);
      return res;
    },

    async toggleIsSplitEnabled(configIndex: number): Promise<any> {
      if (!(await isSplitPluginInstalled(splitLockerClient, chainId))) {
        console.log("Split plugin not installed.");
        return null;
      }
      const res = await splitLockerClient.pauseAutomation({
        args: [configIndex],
      });
      return res;
    },

    async split(configIndex: number): Promise<any> {
      if (!(await isSplitPluginInstalled(splitLockerClient, chainId))) {
        console.log("Split plugin not installed.");
        return null;
      }
      const res = await splitLockerClient.split({
        args: [BigInt(configIndex)],
      });
      return res;
    },

    async deleteSplit(configIndex: bigint): Promise<any> {
      if (!(await isSplitPluginInstalled(splitLockerClient, chainId))) {
        console.log("Split plugin not installed.");
        return null;
      }

      const isSplitCreator = await client.readContract({
        address: chainToSplitPluginAddress[chain.id],
        abi: SplitPluginAbi,
        functionName: "isSplitCreator",
        args: [configIndex, await splitLockerClient.getAddress()],
      });
      if (!isSplitCreator) {
        console.log(
          "You are not the creator of this split config:",
          Number(configIndex)
        );
        return null;
      }

      console.log("Deleting Split Config...");
      const res = await splitLockerClient.deleteSplitConfig({
        args: [configIndex],
      });
      console.log("Waiting for deletion confirmation...");
      await waitForTransaction(res.hash, alchemyRpcUrl);
      return res;
    },
  };
}
</file>

<file path="packages/core/bridge/providers/cctp/cctpConstants.ts">
import { EChain } from "../../../accounts/tokens.js";

/**
 * https://developers.circle.com/stablecoins/supported-domains
 */
export const CCTP_DOMAIN_IDS: Record<EChain, number> = {
    // [EChain.ETHEREUM]: 0,
    // [EChain.AVALANCHE]: 1,
    // [EChain.OPTIMISM]: 2,
    // [EChain.ARBITRUM]: 3,
    // [EChain.NOBLE]: 4,
    [EChain.BASE]: 6,
    [EChain.BASE_SEPOLIA]: 6,
    [EChain.SEPOLIA]: 0,
    [EChain.SOLANA]: 5,
    [EChain.SOLANA_DEVNET]: 5,
    // polygon: 7,
    // sui: 8,
    // aptos: 9,
    // unichain: 10,
};


export const CIRCLE_CONFIG: Record<EChain, {
    irisApiUrl: string;
}> = {
    [EChain.SOLANA_DEVNET]: {
        "irisApiUrl": "https://iris-api-sandbox.circle.com",
    },
    [EChain.SOLANA]: {
        "irisApiUrl": "https://iris-api.circle.com",
    },
    [EChain.BASE]: {
        "irisApiUrl": "https://iris-api.circle.com",
    },
    [EChain.BASE_SEPOLIA]: {
        "irisApiUrl": "https://iris-api-sandbox.circle.com",
    },
    [EChain.SEPOLIA]: {
        "irisApiUrl": "https://iris-api-sandbox.circle.com",
    },
}

/**
 * https://developers.circle.com/stablecoins/evm-smart-contracts
 */
export const CCTP_EVM_CONTRACTS = {
    V1: {
        MESSAGE_TRANSMITTER: {
            [EChain.BASE]: "0xAD09780d193884d503182aD4588450C416D6F9D4",
            [EChain.BASE_SEPOLIA]: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
            [EChain.SEPOLIA]: "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD",
        }
    }
}
</file>

<file path="packages/core/bridge/providers/cctp/cctpUtils.ts">
import * as anchor from "@coral-xyz/anchor";
import { PublicKey, Connection } from '@solana/web3.js';
import fetch from 'node-fetch';
import { getAssociatedTokenAddress, getAccount } from "@solana/spl-token";
import type { Address } from "viem";

import { type MessageTransmitter } from './target/types/message_transmitter';
import { type TokenMessengerMinter } from './target/types/token_messenger_minter';
import * as MessageTransmitterIDL from './target/idl/message_transmitter.json';
import * as TokenMessengerMinterIDL from './target/idl/token_messenger_minter.json';
import * as evmMessageTransmitterAbi from './abi/evm/message_transmitter.json';
import { EChain } from "../../../accounts/tokens.js";
import { CCTP_DOMAIN_IDS, CCTP_EVM_CONTRACTS } from './cctpConstants.js';
import type { IBridgeFromSolanaParams } from "../../types.js";
/**
 * Returns the Anchor programs for MessageTransmitter + TokenMessengerMinter.
 */
export const getPrograms = (provider: anchor.AnchorProvider) => {
    // Initialize contracts
    // Initialize workspace with explicit program IDs from devnet
    const messageTransmitterProgram = new anchor.Program(
        // You'll need to import these IDLs
        MessageTransmitterIDL as anchor.Idl,
        new PublicKey("CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd"),
        provider
    ) as anchor.Program<MessageTransmitter>;

    const tokenMessengerMinterProgram = new anchor.Program(
        TokenMessengerMinterIDL as anchor.Idl,
        new PublicKey("CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3"),
        provider
    ) as anchor.Program<TokenMessengerMinter>;

    return { messageTransmitterProgram, tokenMessengerMinterProgram };
}
/**
 * Finds PDAs needed for depositForBurn.
 */
export const getDepositForBurnPdas = (
    { messageTransmitterProgram, tokenMessengerMinterProgram }: ReturnType<typeof getPrograms>,
    usdcAddress: PublicKey,
    destinationDomain: number
) => {
    const messageTransmitterAccount = findProgramAddress("message_transmitter", messageTransmitterProgram.programId);
    const tokenMessengerAccount = findProgramAddress("token_messenger", tokenMessengerMinterProgram.programId);
    const tokenMinterAccount = findProgramAddress("token_minter", tokenMessengerMinterProgram.programId);
    const localToken = findProgramAddress("local_token", tokenMessengerMinterProgram.programId, [usdcAddress]);
    const remoteTokenMessengerKey = findProgramAddress("remote_token_messenger", tokenMessengerMinterProgram.programId, [
        destinationDomain.toString(),
    ]);
    const authorityPda = findProgramAddress("sender_authority", tokenMessengerMinterProgram.programId);

    return {
        messageTransmitterAccount,
        tokenMessengerAccount,
        tokenMinterAccount,
        localToken,
        remoteTokenMessengerKey,
        authorityPda,
    };
};

/**
 * Helper function to fetch Circle's attestation data for a specific Solana transaction.
 */
export async function getMessages(txHash: string, irisApiUrl: string, solanaChain: EChain) {
    let attestationResponse: any = {};
    const solanaDomain = CCTP_DOMAIN_IDS[solanaChain];

    while (
        attestationResponse.error ||
        !attestationResponse.messages ||
        attestationResponse.messages?.[0]?.attestation === 'PENDING'
    ) {
        const response = await fetch(`${irisApiUrl}/messages/${solanaDomain}/${txHash}`);
        attestationResponse = await response.json();
        // Wait 2 seconds to avoid potential rate-limiting
        if (
            attestationResponse.error ||
            !attestationResponse.messages ||
            attestationResponse.messages?.[0]?.attestation === 'PENDING'
        ) {
            await new Promise((resolve) => setTimeout(resolve, 2000));
        }
    }
    return attestationResponse;
}

/**
 * Convert an EVM address (0x1234...) into a zero-padded 32-byte hex string.
 */
export function evmAddressToBytes32(address: string): `0x${string}` {
    return `0x000000000000000000000000${address.replace('0x', '')}` as `0x${string}`;
}

/**
 * Convenience wrapper for PublicKey.findProgramAddressSync
 */
export function findProgramAddress(
    label: string,
    programId: PublicKey,
    extraSeeds: (string | number[] | Buffer | PublicKey)[] = []
) {
    const seeds = [Buffer.from(anchor.utils.bytes.utf8.encode(label))];
    for (const extraSeed of extraSeeds) {
        if (typeof extraSeed === 'string') {
            seeds.push(Buffer.from(anchor.utils.bytes.utf8.encode(extraSeed)));
        } else if (Array.isArray(extraSeed)) {
            seeds.push(Buffer.from(new Uint8Array(extraSeed)));
        } else if (Buffer.isBuffer(extraSeed)) {
            seeds.push(Buffer.from(extraSeed));
        } else {
            seeds.push(Buffer.from(extraSeed.toBuffer()));
        }
    }
    const [publicKey, bump] = PublicKey.findProgramAddressSync(seeds, programId);
    return { publicKey, bump };
}

export async function findOrCreateUserTokenAccount(
    params: IBridgeFromSolanaParams
): Promise<PublicKey> {
    const { solanaSigner, solanaTokenAddress, solanaRpcUrl } = params;
    const solanaTokenPublicKey = new PublicKey(solanaTokenAddress);
    const connection = new Connection(solanaRpcUrl);

    try {
        // Get the associated token account address
        const tokenAccount = await getAssociatedTokenAddress(
            solanaTokenPublicKey,
            solanaSigner.publicKey
        );

        // Check if the account exists
        await getAccount(connection, tokenAccount);

        return tokenAccount;
    } catch (error) {
        throw new Error("Token account not found");
    }
}

export function getMessageTransmitterFromChain(chain: EChain) {
    if (chain === EChain.SOLANA || chain === EChain.SOLANA_DEVNET) {
        throw new Error(`Unsupported chain: ${chain}`);
    }

    const address = CCTP_EVM_CONTRACTS.V1.MESSAGE_TRANSMITTER[chain] as Address;
    console.log('Message transmitter address:', address);
    return {
        abi: evmMessageTransmitterAbi,
        address,
    }
}
</file>

<file path="packages/core/index.ts">
export * from "./accounts/index.js";
export * from "./bridge/index.js";
export * from './accounts/tokens.js';
export * from "./plugins/index.js";
export * from "./trade/index.js";
</file>

<file path="contracts/src/plugins/split/SplitPlugin.sol">
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.19;

import {BasePlugin} from "@modular-account/plugins/BasePlugin.sol";
import {IPluginExecutor} from "@modular-account/interfaces/IPluginExecutor.sol";
import {IStandardExecutor} from "@modular-account/interfaces/IStandardExecutor.sol";
import {
    ManifestFunction,
    ManifestExecutionHook,
    ManifestAssociatedFunctionType,
    ManifestAssociatedFunction,
    PluginManifest,
    PluginMetadata,
    IPlugin
} from "@modular-account/interfaces/IPlugin.sol";
import {IERC20} from "forge-std/interfaces/IERC20.sol";
import {UserOperation} from "@modular-account/interfaces/erc4337/UserOperation.sol";
import {SIG_VALIDATION_PASSED} from "@modular-account/libraries/Constants.sol";

/// @title Split Plugin
/// @author Locker
/// @notice This plugin lets users automatically split tokens on any executoin.
contract SplitPlugin is BasePlugin {
    string public constant NAME = "Split Plugin";
    string public constant VERSION = "0.0.1";
    string public constant AUTHOR = "Locker";

    // Dependency indices for using the MultiOwner plugin for validation.
    uint256 internal constant _MANIFEST_DEPENDENCY_INDEX_OWNER_RUNTIME_VALIDATION = 0;
    uint256 internal constant _MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION = 1;

    // Split config consts
    uint8 internal constant MAX_TOKEN_CONFIGS = 5;
    uint8 internal constant MAX_SPLIT_RECIPIENTS = 10;
    uint32 internal constant MAX_PERCENTAGE = 10000000;

    struct SplitConfig {
        address tokenAddress; // tokenAddress to be split
        address[] splitAddresses; // receiver addresses of the split
        uint32[] percentages; // respective percentages of each splitAddress
        uint256 minTokenAmount; // minimum token amount that can be split
        bool isSplitEnabled; // execute split in postExec hook
    }

    event SplitConfigCreated(address indexed user, uint256 indexed configIndex);
    event SplitExecuted(uint256 indexed configIndex);
    event SplitConfigDeleted(uint256 indexed configIndex);
    event AutomationSwitched(uint256 indexed configIndex, bool currentState);

    mapping(address => uint256[]) public splitConfigIndexes;
    mapping(uint256 => SplitConfig) public splitConfigs;
    uint256 public splitConfigCount;

    /// @dev Creates a split configuration for the user
    function createSplit(address _tokenAddress, address[] memory _splitAddresses, uint32[] memory _percentages)
        public
    {
        require(_splitAddresses.length > 0, "SplitPlugin: No split addresses provided");
        require(_splitAddresses.length < MAX_TOKEN_CONFIGS, "SplitPlugin: Split addresses limit exceeded");
        require(
            _splitAddresses.length == _percentages.length,
            "SplitPlugin: Number of split addresses and percentages must be the same"
        );
        uint256[] storage userIndexes = splitConfigIndexes[msg.sender];
        require(userIndexes.length < MAX_SPLIT_RECIPIENTS, "SplitPlugin: Number of split addresses limit reached");
        for (uint256 i = 0; i < userIndexes.length; i++) {
            if (splitConfigs[userIndexes[i]].tokenAddress == _tokenAddress) {
                revert("SplitPlugin: Config for token already exists");
            }
        }
        uint64 minimumPercentage = MAX_PERCENTAGE;
        uint64 totalPercentage = 0;
        for (uint8 i = 0; i < _percentages.length; i++) {
            if(_percentages[i] < minimumPercentage) {
                minimumPercentage = _percentages[i];
            }
            totalPercentage += _percentages[i];
        }
        require(totalPercentage == MAX_PERCENTAGE, "SplitPlugin: Invalid percentages");
        uint256 minTokenAmount = MAX_PERCENTAGE / minimumPercentage;
        uint256 currentSplitConfigIndex = splitConfigCount;
        splitConfigCount++;
        SplitConfig memory config = SplitConfig(_tokenAddress, _splitAddresses, _percentages,minTokenAmount, true);

        userIndexes.push(currentSplitConfigIndex);
        splitConfigs[currentSplitConfigIndex] = config;

        emit SplitConfigCreated(msg.sender, currentSplitConfigIndex);
    }

    /// @dev Pauses the automation for the given split config
    function toggleIsSplitEnabled(uint256 _configIndex) external {
        require(isSplitCreator(_configIndex, msg.sender), "SplitPlugin: Only the creator can toggle the automation");
        SplitConfig storage config = splitConfigs[_configIndex];
        bool automationState = config.isSplitEnabled;
        config.isSplitEnabled = !automationState;

        emit AutomationSwitched(_configIndex, !automationState);
    }

    /// @dev Splits the token balance of the user for a config
    function split(uint256 _configIndex) public {
        SplitConfig memory config = splitConfigs[_configIndex];
        IERC20 token = IERC20(config.tokenAddress);
        uint256 totalSplitAmount = token.balanceOf(address(msg.sender));
        if (!config.isSplitEnabled || config.minTokenAmount > totalSplitAmount) {
            return;
        } 

        for (uint256 i = 0; i < config.splitAddresses.length; i++) {
            uint256 amount = (totalSplitAmount * config.percentages[i]) / MAX_PERCENTAGE;
            IPluginExecutor(msg.sender).executeFromPluginExternal(
                    config.tokenAddress,
                    0,
                    abi.encodeWithSelector(IERC20.transfer.selector, config.splitAddresses[i], amount)
                );
        }

        emit SplitExecuted(_configIndex);
    }

    /// @dev Updates the split limit for the given split config
    function updateSplitConfig(uint256 _configIndex, address[] memory _splitAddresses, uint32[] memory _percentages)
        external
    {
        require(isSplitCreator(_configIndex, msg.sender), "SplitPlugin: Only the creator can update the split config");

        uint64 totalPercentage = 0;
        for (uint8 i = 0; i < _percentages.length; i++) {
            totalPercentage += _percentages[i];
        }
        require(totalPercentage == MAX_PERCENTAGE, "SplitPlugin: Invalid percentages");
        require(
            _splitAddresses.length == _percentages.length,
            "SplitPlugin: Number of split addresses and percentages must be the same"
        );

        SplitConfig storage config = splitConfigs[_configIndex];
        config.splitAddresses = _splitAddresses;
        config.percentages = _percentages;
    }

    /// @dev Deletes the split config and removes the index from the user's splitConfigIndexes
    function deleteSplitConfig(uint256 _configIndex) external {
        uint256[] storage userIndexes = splitConfigIndexes[msg.sender];
        for (uint8 i = 0; i < userIndexes.length; i++) {
            if (_configIndex == userIndexes[i]) {
                userIndexes[i] = userIndexes[userIndexes.length - 1];
                userIndexes.pop();
                delete splitConfigs[_configIndex];
                emit SplitConfigDeleted(_configIndex);
                return;
            }
        }
    }

    /// @dev Checks if the given address is the creator of the split config
    function isSplitCreator(uint256 _configIndex, address _splitCreator) public view returns (bool) {
        bool isCreator = false;
        uint256[] memory splitIndexes = splitConfigIndexes[_splitCreator];
        for (uint8 i = 0; i < splitIndexes.length; i++) {
            if (_configIndex == splitIndexes[i]) {
                isCreator = true;
                return isCreator;
            }
        }
        return isCreator;
    }

    function getSplitConfig(uint256 _configIndex)
        external
        view
        returns (
            address tokenAddress,
            address[] memory splitAddresses,
            uint32[] memory percentages,
            uint256 minTokenAmount,
            bool isSplitEnabled
        )
    {
        SplitConfig memory config = splitConfigs[_configIndex];
        return (config.tokenAddress, config.splitAddresses, config.percentages, config.minTokenAmount,config.isSplitEnabled);
    }

    /// @dev Returns the split config indexes for the user
    function getSplitIndexes(address _user) external view returns (uint256[] memory) {
        return splitConfigIndexes[_user];
    }

    function _onInstall(bytes calldata data) internal override {
        (address tokenAddress, address[] memory splitAddresses, uint32[] memory percentages) =
            abi.decode(data, (address, address[], uint32[]));
        createSplit(tokenAddress, splitAddresses, percentages);
    }

    function onUninstall(bytes calldata) external override {
        delete splitConfigIndexes[msg.sender];
    }

    function postExecutionHook(uint8, bytes calldata) external virtual override {
        uint256[] memory configIndexes = splitConfigIndexes[msg.sender];
        if (configIndexes.length == 0) {
            return;
        }
        for (uint256 i = 0; i < configIndexes.length; i++) {
            split(configIndexes[i]);
        }
    }

    /// @notice This function is overridden solely to satisfy the BasePlugin interface.
    /// @dev Since validation is delegated to the MultiOwner plugin, this function should never be called.
    function userOpValidationFunction(
        uint8, // functionId
        UserOperation calldata, // userOp
        bytes32 // userOpHash
    ) external pure override returns (uint256) {
        revert("SplitPlugin: use dependency for validation");
    }

    /// @notice Plugin manifest describing this plugin's functions and validations.
    /// @dev The manifest delegates both userOp and runtime validation to a dependency at index 0.
    function pluginManifest() external pure override returns (PluginManifest memory manifest) {
        // Declare two dependencies.
        manifest.dependencyInterfaceIds = new bytes4[](2);
        manifest.dependencyInterfaceIds[_MANIFEST_DEPENDENCY_INDEX_OWNER_RUNTIME_VALIDATION] = type(IPlugin).interfaceId;
        manifest.dependencyInterfaceIds[_MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION] = type(IPlugin).interfaceId;

        // List the execution functions provided by this plugin.
        manifest.executionFunctions = new bytes4[](5);
        manifest.executionFunctions[0] = this.createSplit.selector;
        manifest.executionFunctions[1] = this.toggleIsSplitEnabled.selector;
        manifest.executionFunctions[2] = this.split.selector;
        manifest.executionFunctions[3] = this.updateSplitConfig.selector;
        manifest.executionFunctions[4] = this.deleteSplitConfig.selector;

        // Delegate user operation validation to the dependency in slot 1.
        manifest.userOpValidationFunctions = new ManifestAssociatedFunction[](5);
        manifest.userOpValidationFunctions[0] = ManifestAssociatedFunction({
            executionSelector: this.createSplit.selector,
            associatedFunction: ManifestFunction({
                functionType: ManifestAssociatedFunctionType.DEPENDENCY,
                functionId: 0,
                dependencyIndex: _MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION
            })
        });
        manifest.userOpValidationFunctions[1] = ManifestAssociatedFunction({
            executionSelector: this.toggleIsSplitEnabled.selector,
            associatedFunction: ManifestFunction({
                functionType: ManifestAssociatedFunctionType.DEPENDENCY,
                functionId: 0,
                dependencyIndex: _MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION
            })
        });
        manifest.userOpValidationFunctions[2] = ManifestAssociatedFunction({
            executionSelector: this.split.selector,
            associatedFunction: ManifestFunction({
                functionType: ManifestAssociatedFunctionType.DEPENDENCY,
                functionId: 0,
                dependencyIndex: _MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION
            })
        });
        manifest.userOpValidationFunctions[3] = ManifestAssociatedFunction({
            executionSelector: this.updateSplitConfig.selector,
            associatedFunction: ManifestFunction({
                functionType: ManifestAssociatedFunctionType.DEPENDENCY,
                functionId: 0,
                dependencyIndex: _MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION
            })
        });
        manifest.userOpValidationFunctions[4] = ManifestAssociatedFunction({
            executionSelector: this.deleteSplitConfig.selector,
            associatedFunction: ManifestFunction({
                functionType: ManifestAssociatedFunctionType.DEPENDENCY,
                functionId: 0,
                dependencyIndex: _MANIFEST_DEPENDENCY_INDEX_OWNER_USER_OP_VALIDATION
            })
        });

        ManifestFunction memory preExecution =
            ManifestFunction({functionType: ManifestAssociatedFunctionType.NONE, functionId: 0, dependencyIndex: 0});

        ManifestFunction memory postExecution =
            ManifestFunction({functionType: ManifestAssociatedFunctionType.SELF, functionId: 0, dependencyIndex: 0});

        manifest.executionHooks = new ManifestExecutionHook[](1);
        manifest.executionHooks[0] = ManifestExecutionHook({
            executionSelector: IStandardExecutor.execute.selector,
            preExecHook: preExecution,
            postExecHook: postExecution
        });

        // We do not use runtime validation, so leave these arrays empty.
        manifest.runtimeValidationFunctions = new ManifestAssociatedFunction[](0);
        manifest.preRuntimeValidationHooks = new ManifestAssociatedFunction[](0);

        // Set permissions.
        manifest.permitAnyExternalAddress = true;
        manifest.canSpendNativeToken = true;
        manifest.permittedExecutionSelectors = new bytes4[](0);

        return manifest;
    }

    function pluginMetadata() external pure virtual override returns (PluginMetadata memory) {
        PluginMetadata memory metadata;
        metadata.name = NAME;
        metadata.version = VERSION;
        metadata.author = AUTHOR;
        return metadata;
    }
}
</file>

<file path="packages/core/bridge/providers/cctp/cctpBridge.ts">
import { Connection, Keypair, PublicKey } from '@solana/web3.js';
import { hexToBytes, keccak256, toHex, encodeAbiParameters, type Address } from 'viem';
import * as spl from '@solana/spl-token';
import * as anchor from "@coral-xyz/anchor";

import { CCTP_DOMAIN_IDS, CIRCLE_CONFIG } from './cctpConstants.js';
import { evmAddressToBytes32, findOrCreateUserTokenAccount, getDepositForBurnPdas, getMessages, getPrograms, getMessageTransmitterFromChain } from './cctpUtils.js';
import type { IBridgeFromSolanaParams, IBridgeFromSolanaResponse } from '../../types.js';
import type { ILockerClient } from '../../../accounts/types.js';
import { USDC } from '../../../accounts/tokens.js';

export interface ICctpBridgeFromSolanaResponse extends IBridgeFromSolanaResponse {
    attestation: string;
    message: string;
    eventNonce: string;
}

/**
 * Bridges tokens from Solana -> EVM using Circle's CCTP.
 */
export async function cctpBridgeTokenFromSolana(params: IBridgeFromSolanaParams): Promise<ICctpBridgeFromSolanaResponse> {
    const {
        solanaSigner,
        solanaTokenAddress,
        amount,
        recipientAddress,
        recipientChain,
        solanaChain,
        solanaRpcUrl
    } = params;

    const {
        irisApiUrl,
    } = CIRCLE_CONFIG[solanaChain];

    // CCTP has bespoke domain IDs for each chain. These do not correspond to EVM
    const destinationDomainId = CCTP_DOMAIN_IDS[recipientChain];

    // SPL token account for the user
    const userTokenAccount = await findOrCreateUserTokenAccount(
        params
    );

    const expectedTokenAddress = USDC[solanaChain];
    if (solanaTokenAddress !== expectedTokenAddress) {
        throw new Error(`Cannot bridge token ${solanaTokenAddress} with CCTP in on ${solanaChain}. Expected USDC at ${expectedTokenAddress}.`);
    }

    // Create a new Provider based on the signer's Keypair
    const connection = new Connection(solanaRpcUrl);
    const provider = new anchor.AnchorProvider(
        connection,
        new anchor.Wallet(solanaSigner),
        {}
    );
    anchor.setProvider(provider);

    const { messageTransmitterProgram, tokenMessengerMinterProgram } = getPrograms(provider);

    // Convert the EVM address into a 32-byte format
    const evmRecipientBytes32 = evmAddressToBytes32(recipientAddress);
    const mintRecipient = new PublicKey(hexToBytes(evmRecipientBytes32));

    // Get PDAs
    const usdcPublicKey = new PublicKey(solanaTokenAddress);
    const pdas = getDepositForBurnPdas(
        { messageTransmitterProgram, tokenMessengerMinterProgram },
        usdcPublicKey,
        destinationDomainId
    );

    // Generate a new keypair for the MessageSent event account.
    const messageSentEventAccountKeypair = Keypair.generate();

    // Anchor RPC call
    console.log('Depositing for burn...');
    const depositForBurnTx = await tokenMessengerMinterProgram.methods
        .depositForBurn({
            amount: new anchor.BN(amount),
            destinationDomain: destinationDomainId,
            mintRecipient,
        })
        .accounts({
            owner: provider.wallet.publicKey,
            eventRentPayer: provider.wallet.publicKey,
            senderAuthorityPda: pdas.authorityPda.publicKey,
            burnTokenAccount: userTokenAccount,
            messageTransmitter: pdas.messageTransmitterAccount.publicKey,
            tokenMessenger: pdas.tokenMessengerAccount.publicKey,
            remoteTokenMessenger: pdas.remoteTokenMessengerKey.publicKey,
            tokenMinter: pdas.tokenMinterAccount.publicKey,
            localToken: pdas.localToken.publicKey,
            burnTokenMint: usdcPublicKey,
            messageTransmitterProgram: messageTransmitterProgram.programId,
            tokenMessengerMinterProgram: tokenMessengerMinterProgram.programId,
            messageSentEventData: messageSentEventAccountKeypair.publicKey,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
        })
        .signers([messageSentEventAccountKeypair])
        .rpc();

    // Fetch attestation from the Attestation Service
    console.log(`Fetching attestation for tx ${depositForBurnTx}`);
    const response = await getMessages(depositForBurnTx, irisApiUrl, solanaChain);
    const { attestation, message, eventNonce } = response.messages[0];

    // (Optional) reclaim event account rent
    console.log('Reclaiming event account...');
    const reclaimEventAccountTx = await messageTransmitterProgram.methods
        .reclaimEventAccount({
            attestation: Buffer.from(attestation.replace("0x", ""), "hex"),
        })
        .accounts({
            payee: provider.wallet.publicKey,
            messageTransmitter: pdas.messageTransmitterAccount.publicKey,
            messageSentEventData: messageSentEventAccountKeypair.publicKey,
        })
        .rpc();

    return {
        depositTx: depositForBurnTx,
        reclaimTx: reclaimEventAccountTx,
        attestation,
        message,
        eventNonce,
        recipientChain,
    }
}

/**
 * Receives tokens bridged from Solana -> EVM using Circle's CCTP.
 */
export async function cctpReceiveTokenFromSolana(
    cctpResponse: ICctpBridgeFromSolanaResponse,
    lockerClient: ILockerClient,
): Promise<ICctpBridgeFromSolanaResponse> {
    const {
        attestation,
        message,
        recipientChain,
    } = cctpResponse;
    console.log('CCTP receive token from Solana...');
    console.log('Attestation:', attestation);
    console.log('Message:', message);
    console.log('Recipient chain:', recipientChain);

    const messageTransmitter = getMessageTransmitterFromChain(recipientChain);

    const selector = keccak256(toHex('receiveMessage(bytes,bytes)')).slice(0, 10);
    const suffixData = encodeAbiParameters(
        [
            { name: "message", type: "bytes" },
            { name: "attestation", type: "bytes" },
        ],
        [message as Address, attestation as Address]
    );
    const data = selector + suffixData.slice(2);

    // Sends a receiveMessage userOp to complete the bridge
    const response = await lockerClient.sendUserOps(messageTransmitter.address, data as Address, BigInt(0));
    return response;
}
</file>

<file path="packages/core/package.json">
{
  "name": "@locker-labs/sdk",
  "version": "0.0.1",
  "author": "Locker",
  "main": "./_cjs/index.js",
  "module": "./_esm/index.js",
  "types": "./_types/index.d.ts",
  "typings": "./_types/index.d.ts",
  "type": "module",
  "sideEffects": false,
  "description": "A utility library for enhancing your ERC-4337 experience",
  "keywords": [
    "ethereum",
    "erc-4337",
    "erc-6900",
    "split",
    "round up savings",
    "yield"
  ],
  "license": "MIT",
  "files": [
    "_esm",
    "_cjs",
    "_types",
    "./**/*.ts",
    "!_esm/**/*.tsbuildinfo",
    "!_cjs/**/*.tsbuildinfo",
    "!_types/**/*.tsbuildinfo",
    "!.env",
    "!./**/*.test.ts",
    "!.changeset"
  ],
  "devDependencies": {
    "@account-kit/plugingen": "^4.19.0",
    "@types/bun": "latest",
    "@types/node-fetch": "^2.6.12"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "scripts": {
    "build": "bun run clean && bun run build:cjs && bun run build:esm && bun run build:types",
    "build:cjs": "tsc --module commonjs --outDir ./_cjs --removeComments --verbatimModuleSyntax false && printf '{\"type\":\"commonjs\"}' > ./_cjs/package.json",
    "build:esm": "tsc --module es2015 --outDir ./_esm && printf '{\"type\": \"module\",\"sideEffects\":false}' > ./_esm/package.json",
    "build:types": "tsc --module esnext --declarationDir ./_types --emitDeclarationOnly --declaration --declarationMap",
    "clean": "rimraf _esm _cjs _types",
    "format": "biome format . --write",
    "lint": "biome check .",
    "lint:fix": "bun run lint --apply"
  },
  "exports": {
    ".": {
      "types": "./_types/index.d.ts",
      "import": "./_esm/index.js",
      "default": "./_cjs/index.js"
    },
    "./accounts": {
      "types": "./_types/accounts/index.d.ts",
      "import": "./_esm/accounts/index.js",
      "default": "./_cjs/accounts/index.js"
    },
    "./bridge": {
      "types": "./_types/bridge/index.d.ts",
      "import": "./_esm/bridge/index.js",
      "default": "./_cjs/bridge/index.js"
    },
    "./plugins": {
      "types": "./_types/plugins/index.d.ts",
      "import": "./_esm/plugins/index.js",
      "default": "./_cjs/plugins/index.js"
    }
  },
  "typesVersions": {
    "*": {
      "accounts": [
        "./_types/accounts/index.d.ts"
      ],
      "bridge": [
        "./_types/bridge/index.d.ts"
      ],
      "plugins": [
        "./_types/plugins/index.d.ts"
      ]
    }
  },
  "dependencies": {
    "@account-kit/smart-contracts": "^4.20.1",
    "@coral-xyz/anchor": "^0.28.0",
    "@solana/spl-token": "^0.3.8",
    "@solana/web3.js": "^1.90.2",
    "dotenv": "^16.4.7",
    "dotenv-expand": "^12.0.1",
    "rimraf": "^6.0.1",
    "viem": "^2.24.1"
  }
}
</file>

<file path="packages/examples/bridge-and-split/index.ts">
import { Keypair } from '@solana/web3.js';
import bs58 from 'bs58';
import { type Address } from "viem";
import { LocalAccountSigner } from "@aa-sdk/core";
import {
  bridgeAndReceiveTokenFromSolana,
  USDC,
  createLockerSplitClient,
  type IBridgeName,
  EChain,
} from "@locker-labs/sdk";
import * as dotenv from "dotenv";

dotenv.config();

/*
 * Load environment variables
 */
const solanaPrivateKeyB58 = process.env.SOLANA_PRIVATE_KEY_BS58;
if (!solanaPrivateKeyB58) {
  throw new Error("SOLANA_PRIVATE_KEY_BS58 is not set");
}

const solanaRpcUrl = process.env.SOLANA_RPC_URL;
if (!solanaRpcUrl) {
  throw new Error("SOLANA_RPC_URL is not set");
}

const evmPrivateKey = process.env.EVM_PRIVATE_KEY;
if (!evmPrivateKey) {
  throw new Error("EVM_PRIVATE_KEY is not set");
}

const alchemyApiKey = process.env.ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  throw new Error("ALCHEMY_API_KEY is not set");
}

/*
 * Runtime configs
 */

// Bridge config
const sourceChain = EChain.SOLANA_DEVNET;
const recipientChain = EChain.BASE_SEPOLIA;
const usdcAmount = 10000; // 0.01 USDC

// Split config
const splitRecipients = [
  "0xd7F723f8EDeC8D6D62caa4Ecc2b5Ca1292618355",
  "0x1ECF3f51A771983C150b3cB4A2162E89c0A046Fc",
] as Address[];
const splitPercentages = [BigInt(9500000), BigInt(500000)]; // Recipient 0 gets 95%, Recipient 1 gets 5%

/*
 * Implementation
 */

const sourceChainToken = USDC[sourceChain];
const recipientChainToken = USDC[recipientChain] as Address;
const bridgeName: IBridgeName = "cctp";

// Create a Locker Client
const splitClient = await createLockerSplitClient({
  salt: BigInt(0),
  alchemyApiKey,
  chain: recipientChain,
  signer: LocalAccountSigner.privateKeyToAccountSigner(
    evmPrivateKey as Address
  ),
});

// console.log(await splitClient.installedPlugins({}));

// Get address for the Locker Client. This is the address that will receive the token then split it.
const recipientAddress = splitClient.getAddress();
console.log(`Recipient address: ${recipientAddress}`);

// One time configuration of Locker Split Client
await splitClient.installSplitPlugin(
  recipientChainToken,
  splitPercentages,
  splitRecipients
);

async function bridgeAndSplit() {
  // CCTP to transfer from Solana to Base
  const solanaPrivateKeyUint8Array = bs58.decode(solanaPrivateKeyB58!);
  const solanaSigner = Keypair.fromSecretKey(solanaPrivateKeyUint8Array);

  console.log(
    `About to bridge from ${sourceChain} to ${recipientChain}: ${solanaSigner.publicKey.toBase58()} -> ${recipientAddress}`
  );

  const params = {
    solanaSigner,
    solanaTokenAddress: sourceChainToken,
    amount: usdcAmount,
    recipientChain,
    recipientAddress,
    bridgeName,
    solanaChain: sourceChain,
    solanaRpcUrl: solanaRpcUrl!,
    lockerClient: splitClient,
  };

  // Bridge and Receive token from Solana
  const response = await bridgeAndReceiveTokenFromSolana(params);
  console.log(`Received token from ${sourceChain} on ${recipientChain}:`);
  console.log(response);
}

async function cleanup() {
  await splitClient.uninstallSplitPlugin();
}

await bridgeAndSplit();
// await cleanup();
</file>

</files>
